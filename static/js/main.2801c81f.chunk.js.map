{"version":3,"sources":["utils/fileUtilsElectron.js","actions/types.js","reducers/viewReducer.js","reducers/imageListReducer.js","reducers/partReducer.js","reducers/channelReducer.js","reducers/markerReducer.js","reducers/entityReducer.js","reducers/rootReducer.js","store.js","components/Header.js","actions/markerActions.js","actions/imageListActions.js","actions/partActions.js","actions/entityActions.js","utils/conversions.js","actions/viewActions.js","hooks/useImageDnDMouseEvent.js","components/ImageList.js","components/ImageListContainer.js","utils/fileUtils.js","utils/imageUtils.js","actions/ioActions.js","actions/channelActions.js","components/HeaderContainer.js","components/ImageControl.js","components/ImageControlContainer.js","components/ChannelMarkers.js","components/ChannelMarkersContainer.js","hooks/useChannelMouseEvent.js","hooks/useDropMouseEvent.js","hooks/useTimeScaleMouseEvent.js","hooks/useMouseEvent.js","components/TimeScale.js","components/timeToPixels.js","components/ImageChannel.js","components/AudioChannel.js","components/Channel.js","player/Playout.js","components/withPlay.js","components/ChannelContainer.js","components/ChannelGroup.js","components/themes.js","components/ChannelGroupContainer.js","components/ImageExporter.js","components/AnimationPane.js","components/AnimationPaneContainer.js","components/ChannelSelector.js","components/TimeScaleSelector.js","components/ChannelSelectorGroup.js","components/ChannelSelectorGroupContainer.js","components/UploadLogViewContainer.js","components/MessageView.js","components/MessageViewContainer.js","App.js","serviceWorker.js","index.js","components/UploadLogView.js"],"names":["app","require","remote","portCache","currentActiveProcess","uploadChannel","uint8array","log","a","dataDir","tmp","dirSync","unsafeCleanup","filename","path","join","name","spiffsFilename","tmpNameSync","getVersion","saveBinaryFile","mkSpiffs","upload","doneMessage","Error","console","error","trace","errorInfo","stack","toString","doneWithErrorMessage","doneWithCancelledMessage","removeCallback","fs","unlink","updateFirmware","downloadDir","assetName","downloadedAsset","downloadFirmware","err","writeFile","getScriptsDir","baseDir","isDev","process","cwd","exePath","getPath","dirname","getScriptsBaseDir","platform","arch","dir","scriptDir","exe","spawn","stdout","on","data","lines","split","stderr","logStr","code","addr","port","params","unshift","m","exec","length","outputdir","filterRelease","filterAsset","asset","release","prerelease","downloadRelease","killCurrentProcess","pid","kill","ADD_CHANNEL","DELETE_CHANNEL","CLEAR_CHANNELS","UPDATE_CHANNEL","SET_CHANNEL_ACTIVE","SET_CHANNEL_INACTIVE","PLAY_CHANNELS","STOP_CHANNEL","STOP_CHANNELS","SELECT_ENTITY","DESELECT_ENTITY","CLEAR_ENTITY_SELECTION","COPY_ENTITIES","CLEAR_IMAGELIST","ADD_IMAGE","REMOVE_IMAGE","CLEAR_PARTS","ADD_PART","DELETE_PART","MOVE_PART","MOVE_PARTS","RESIZE_PART","CLEAR_MARKERS","SET_OR_REPLACE_MARKER","DELETE_MARKER","UPDATE_MARKER","LOAD_SHOW_STARTED","LOAD_SHOW_SUCCESS","LOAD_SHOW_FAILURE","INIT_LOAD_PROGRESS","SET_LOAD_PROGRESS","INCR_LOAD_PROGRESS","CLEAR_VIEW","SELECT_RANGE","DESELECT_RANGE","SET_RESOLUTION","SELECT_IMAGE_CHANNEL","ADD_TO_UPLOAD_LOG","CLEAR_UPLOAD_LOG","SET_MESSAGE","CLEAR_MESSAGE","TOGGLE_SNAP_TO_MARKER","initialState","selection","from","to","type","resolution","selectedImageChannelId","partsToCopy","uploadLog","loadShowStatus","message","loadProgress","base","progress","snapToMarkers","getSelectionRange","state","view","getResolution","getSelectedImageChannelId","getUploadLog","getMessage","isLoadingShow","getSnapToMarkers","combineReducers","byImageId","action","payload","imageId","newByImageId","cloneDeep","allImageIds","filter","p","getImages","entities","images","getImageList","Object","values","imageExists","id","includes","partSchema","schema","Entity","idAttribute","byPartId","part0","partId","currentOffset0","actOffset","offset","partUpdate0","movePartWithSnap","duration","incr","snapPositions","snapDist","newPart0","getIncrWithSnap","partIds","newByPartId","forEach","part","newPart1","part1","snapDist1","minDur1","minDuration","snapPositions1","bound","rightBound1","currentOffset1","actualOffset1","snapOffsetLeft1","snapTo","updatedOffset1","actRightBound","rightBound2","actualRightBound2","snapOffsetRight2","updatedDuration2","newState","allPartIds","result","partIdsToMove","partsById","reduce","minId","maxId","updatedOffset","updatedIncr","snapOffsetLeft","snapOffsetRight","val","leftBound","rightBound","left","right","Math","max","min","posToSnap","maxDist","snapDiffLeft","myPos","diffs","map","pos","abs","idx","iMin","i","dif","Number","isInteger","diff","closestSnapDiff","partExists","parts","getPart","getParts","denormalize","getChannelId","channelId","achannelSchema","thechannelsSchema","byChannelId","partId0","channel0","parts0","duration0","partId2","channelId2","channel2","parts2","channelId1","channel1","allChannelIds","activeChannels","playingChannels","getAllChannelIds","channels","sort","chId1","chId2","localeCompare","channelExists","isChannelActive","allChannelsStopped","getActiveChannelIds","activeChannelIds","ch","_getChannel","_getChannelType","getChannelSampleRate","sampleRate","getChannelSnapDist","getMaxChannelDuration","getNumChannels","channeld","_getChannelDuration","_getEntities","getDenormalizedChannel","getAllDenormalizedChannels","byMarkerId","markerId","newByMarkerId","prevMarker","allMarkerIds","getAllMarkerPosOfType","markers","marker","markerExists","partReducer","imageListReducer","markerReducer","channelReducer","selectedEntityIds","entityIdsToCopy","entityExists","entityId","isEntitySelected","getEntityType","isEntitySelectable","getSelectedEntityType","getSelectedEntityIds","getSelectedEntityIdsOfType","anyEntitySelected","getEntitiesIdsToCopy","updatedProgress","entityReducer","composeEnhancers","window","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","Header","props","loadShowFromFile","evt","preventDefault","target","files","loadAudioFromFile","handleChannelSelectionChange","event","value","setChannelInactive","setChannelActive","setState","this","channelIds","classes","createImageChannel","saveShow","enablePlay","playChannelAndImage","enableStop","stopChannel","zoomIn","zoomOut","entitySelected","deleteSelectedEntities","copyParts","pasteParts","hasPartsToCopy","className","wrapper","headergroup","Tooltip","title","IconButton","color","onClick","fileUpload","click","accept","hidden","ref","onChange","width","loadShow","disabled","Component","withStyles","theme","root","display","justifyContent","flexDirection","margin","padding","whiteSpace","withTheme","lastMarkerIdCount","isValidMarkerType","clearMarkersOfType","dispatch","getState","_deleteMarker","setOrReplaceMarker","markerInfo","_setOrReplaceMarker","deleteMarker","updateMarker","_updateMarker","_getMarkerId","_getPartLeftMarkerId","_getPartRightMarkerId","addPartSelectionMarkers","partInfo","_getSelectedLeftMarker","_getSelectedRightMarker","deletePartSelectionMarkers","addImage","imageInfo","src","height","_addImage","removeImage","_removeImage","saveImageToStorage","image","key","imageStr","JSON","stringify","localStorage","setItem","loadImagesFromStorage","keys","k","startsWith","res","img","parse","getItem","push","lastPartIdCount","generateId","_addPart","normalize","createPart","selectNewPart","toggleEntitySelection","deletePart","moveSelectedParts","moveInfo","markerPositions","_moveParts","syncPartDeps","resizePart","resizeInfo","minPartDuration","getChannelMinPartDuration","_resizePart","leftMarkerId","rightMarkerId","syncPartMarkers","selectInInterval","selectedChannelId","getAllPartIds","getPartIdsInInterval","pId","selectEntity","_selectEntity","deselectEntity","_deselectEntity","clearEntitySelection","entityType","entitySingleSelected","isEntitySingleSelected","toggleMultiEntitySelection","samplesToSeconds","samples","secondsToSamples","seconds","toCeil","ceil","floor","pixelsToSeconds","pixels","secondsToPixels","samplesToRad","rotationSpeed","factor","PI","selectRange","selectInfo","deselectRange","setResolution","_setResolution","updateChannel","addToUploadLog","text","setMessage","count","counterReducer","useImageDnDMouseEvent","useState","dragging","setDragging","useReducer","draggingCounterState","dispatchDraggingCounter","useDispatch","handleMouseEvent","eventName","e","stopPropagation","getAttribute","ctrlKey","handleSelectImage","dataTransfer","fileList","loadImageAndAddToStore","dropImage","file","reader","FileReader","Image","onload","newImage","readAsDataURL","evInfo","ImageListWrapper","styled","div","backgroundColor","borderColor","ImageInList","DropHereLabel","label","ImageList","useEffect","imagesComponent","data-imageid","draggable","onDragStart","setData","dropHereLabel","center","onMouseUp","onDragEnter","onDragEnd","onDragExit","onDragLeave","onDragOver","onDrop","ImageListContainer","selectImage","selectMultiImage","connect","imageFile","downloadFile","element","document","createElement","setAttribute","style","body","appendChild","removeChild","encodeImage","buffer","ArrayBuffer","output","Uint8Array","o","cnt","prev","widthUpper","col","row","s","round","subarray","runtimeEncodeImage","logScale","LogScale","showFile","startInfo","Promise","resolve","reject","fr","readAsText","then","dataObj","_uploadShow","channelInfo","catch","showData","imageListPromises","imageData","loadImage","markerPromises","all","channelPromises","channelData","addChannel","obj","keysToRemove","show","omit","v","undefined","encodeURIComponent","clearExportImage","numChannels","maxDuration","canvas","getElementById","cc","getContext","fillStyle","fillRect","drawExportImage","applyLog","chGain","gain","getChannelGain","getChannelParts","offsetPx","widthPx","drawImage","linearToLogarithmic","globalAlpha","saveImageChannelAsBinary","getChannelExportData","blob","Blob","saveAs","downloadBinaryFile","fromTime","toTime","exportCanvas","exportCc","fromIdx","getImageData","audioFile","audioContext","decodeAudioData","decodedAudio","readAsArrayBuffer","readAudioFile","audioBuffer","playState","active","lastChannelIdCount","Array","isArray","_addChannel","deleteChannel","getChannelPartIds","_deleteChannel","updateInfo","_updateChannel","playActiveChannels","chs","AudioContext","webkitAudioContext","resolutions","HeaderContainer","resetZoom","resolutionIdx","parseInt","Boolean","activeImageChannels","originalPart","partToPaste","isElectron","ImageControlWrapper","ImageControl","saveImagesToStorage","clearImagesfromStorage","clearImageList","formControl","spacing","minWidth","ImageControlContainer","removeItem","ImageProgress","waveProgressColor","waveProgressBorderColor","ImageMarker","markerColor","markerPos","cursor","zIndex","RangeSelection","tempSelectionColor","selectionColor","ChannelMarkers","React","anchorEl","setAnchorEl","openContextMenu","currentTarget","closeContextMenu","progressElem","selectionElem","markerElems","withContextMenu","insertMarkerColor","selectedMarkerColor","selectedMarkerColorOther","markerColorOther","markerProps","onContextMenu","contextMenu","Menu","keepMounted","open","onClose","MenuItem","handleRemoveMarker","defaultProps","ChannelMarkersContainer","progressPx","selectionPx","markerIds","mId1","mId2","getAllMarkerIds","markersPx","getMarker","selected","useChannelMouseEvent","fromX","setFromX","setPartId","setMarkerId","keyAtMouseDown","setKeyAtMouseDown","currAction","setCurrAction","handleChannelMouseEvent","pop","getKey","handleKeyDown","x","handleActionStart","handleMoveTo","handleMultiSelect","selectImageChannel","handleToggleSelection","resetAction","finalizeAction","incrX","moveResizePart","posX","leftX","rightX","handleSelectRange","selectPartInRange","useDropMouseEvent","prevPosX","setPrevPosX","prevTimestamp","setPrevTimestamp","handleInsertMarker","getImageDuration","handleInsertImage","timestamp","useTimeScaleMouseEvent","handleTimeScaleMouseEvent","handleMoveEnd","markerType","handleMoveStart","handleFinalizeMove","handleMove","useMouseEvent","wrapperClassForPosition","handleDropMouseEevent","handleEvent","getMouseEventPosition","getData","adaptedEventName","shiftKey","handleSpecificMouseEvent","timeStamp","el","position","cn","classList","contains","parentNode","parentScroll","scrollLeft","clientX","offsetLeft","debug","TIME_INFO","20000","bigStep","smallStep","secondStep","12000","10000","5000","2500","1500","700","formatTime","milliseconds","PlaylistTimeScale","cssWidth","PlaylistTimeScaleScroll","TimeTicks","timeScaleHeight","TimeStamp","pix","TimeScale","maxWidth","scale","canvasRef","useRef","scaleInfo","item","b","getScaleInfo","canvasInfo","timeMarkers","counter","ctx","current","clearRect","timeColor","scaleHeight","scaleY","draw","onMouseDown","onMouseMove","onMouseLeave","samplesPerPixel","timeToPixels","WrappedComponent","passthruProps","maxWidthPx","partsPx","pixelProps","PureComponent","ImageCanvas","CanvasRefImage","ImageCanvases","ImageChannel","widthFactor","canvaseRefs","imageRefs","nextProps","doUpdate","entries","deepEqual","prevProps","prevState","imageHeight","canvasOffset","c","imageOffset","allImageCanvases","allCanvasRefImages","canvasImages","totalWidth","canvasCount","currentWidth","canvasImage","createCanvasRef","data-partid","String","createImageRef","Waveform","waveHeight","WaveformCanvases","waveFillColor","Channel","canvases","peaks","bits","h2","maxValue","waveOutlineColor","peakSegmentLength","minPeak","maxPeak","waveformCount","waveforms","waveform","ChannelWrapper","addEventListener","removeEventListener","channelWrapperProps","tabIndex","imageBackgroundColorSelected","imageBackgroundColor","channelProps","innerChannel","AudioChannel","Playout","ac","destination","start","shape","FADEIN","createFadeIn","fadeGain","FADEOUT","createFadeOut","applyFade","source","createBufferSource","sourcePromise","onended","disconnect","volumeGain","shouldPlayGain","masterGain","createGain","level","bool","when","stop","withPlay","WithPlay","startPlay","startAt","endAt","playout","isPlaying","actStartAt","actEndAt","trackStartAt","trackDelay","trackEndAt","animateStartAt","animateEndAt","setUpSource","stopPlay","play","currentTime","animationRequest","requestAnimationFrame","animateProgress","animationStartTime","currentTimeInSecs","reportProgress","stopAnimateProgress","cancelAnimationFrame","playStartAt","playEndAt","displayName","getDisplayName","ChannelWithPlay","ChannelContainer","doExtractPeaks","memoize","pixPerSample","extractPeaks","renderProps","getChannelData","ChannelGroupWrapper","drawerWidth","LoadProgressView","CircularProgress","TimeScaleInSecs","ChannelGroup","considerScroll","groupRef","clientWidth","allchannelIds","channelComponents","disableShrink","defaultTheme","ChannelGroupContainer","ImageExporterWrapper","ImageExporterCanvas","ImageExporter","minRotationSpeed","WhiteSlider","Slider","AnimationPaneWrapper","AnimationControl","RotationSpeed","Typography","AnimationCanvas","AnimationPaneWithPlay","handleChange","ev","slider2speed","prevRad","prevTime","innerRadius","initiallyBlack","arcIdx","radius","fromRad","toRad","largestRadius","centerX","centerY","beginPath","arc","strokeStyle","lineWidth","stroke","expData","oneSampleRad","d","numArcs","w","startIdx","dataIdx","drawArc","speed","toFixed","speed2slider","orientation","AnimationPaneContainer","channelSelectorWrapper","border","borderRight","wrapperInActive","background","wrapperSelected","sliderWrapper","icon","fill","button","button1","paddingRight","actionsWrapper","actionsRow","actionsRow2","electronVersion","isImageChannel","classNames","indigo","uploadImageChannelToPoi","duplicateChannel","toPrecision","slider","step","snapWrapper","alignItems","snapButton","snapIcon","checked","tooltipText","toggleSnapToMarkers","formGroup","channelSelectors","getChannelSelectorData","FormGroup","ChannelSelectorGroupContainer","UploadLogView","clearUploadLog","cancelUpload","MessageView","handleClose","clearMessage","messageTitle","messageHtml","Modal","aria-labelledby","aria-describedby","disableBackdropClick","paper","headingArea","variant","textArea","buttonArea","Button","palette","boxShadow","shadows","outline","top","marginBottom","overflow","fontSize","lineHeight","wordBreak","alignSelf","MessageViewContainer","App","handleDrawerOpen","handleDrawerClose","CssBaseline","AppBar","appBar","appBarShift","Toolbar","disableGutters","title1","title2","title3","title4","title5","title6","title7","title8","title9","grow","aria-label","menuButton","hide","content","contentShift","drawerHeader","UploadLogViewContainer","channelPane","Drawer","drawer","anchor","drawerPaper","direction","Divider","flexGrow","transition","transitions","create","easing","sharp","leavingScreen","easeOut","enteringScreen","marginRight","paddingLeft","marginLeft","flexShrink","mixins","toolbar","location","hostname","match","ReactDOM","render","store","createStore","rootReducer","applyMiddleware","thunk","configureStore","navigator","serviceWorker","ready","registration","unregister","handleCancel","logLines","logLinesHtml","line","uploadFinished","overflowX","overflowY"],"mappings":"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","file":"static/js/main.2801c81f.chunk.js","sourcesContent":["import { promises as fs } from \"fs\";\nimport { spawn } from \"promisify-child-process\";\nimport tmp from \"tmp\";\nimport path from \"path\";\nimport kill from \"tree-kill\";\nimport { doneMessage, doneWithErrorMessage, doneWithCancelledMessage } from \"../components/UploadLogView\";\nimport downloadRelease from \"download-github-release\";\nimport isDev from \"electron-is-dev\";\n\nconst {app} = require(\"electron\").remote;\nlet portCache = null;\nlet currentActiveProcess = null;\n\nexport async function uploadChannel(uint8array, log) {\n  const dataDir = tmp.dirSync({\n    unsafeCleanup: true\n  });\n  const filename = path.join(dataDir.name, \"channel.poi\");\n  const spiffsFilename = tmp.tmpNameSync();\n\n  log(`App Version: ${app? app.getVersion() : \"unknown\"}\\n`);\n\n  // 3 steps for upload: save data, generate spiffs file and upload\n  try {\n    await saveBinaryFile(filename, uint8array, log);\n    await mkSpiffs(dataDir.name, spiffsFilename, log);\n    if (currentActiveProcess) {\n      await upload(spiffsFilename, \"0x150000\", portCache, log);\n      log(`${doneMessage}\\n`);\n    } else {\n      throw (new Error(\"cancelled\"));\n    }\n  } catch (err) {\n    if (currentActiveProcess) {\n      console.error(\"Unable to upload channel data:\", err);\n      console.trace();\n      const errorInfo = err.stack ? err.stack : err.toString();\n      log(`${doneWithErrorMessage}: ${errorInfo}\\n`);\n      portCache = null;\n    } else {\n      log(`${doneWithCancelledMessage}\\n`);\n    }\n  }\n\n  // cleanup\n  currentActiveProcess = null;\n  try {\n    dataDir.removeCallback();\n    await fs.unlink(spiffsFilename);\n  } catch (err) {\n    // do nothing, when clean fails\n  }\n\n}\n\nexport async function updateFirmware(log) {\n  const downloadDir = tmp.dirSync({\n    unsafeCleanup: true\n  });\n  const assetName = \"firmware.bin\";\n  const downloadedAsset = path.join(downloadDir.name, assetName);\n\n  log(`App Version: ${app? app.getVersion() : \"unknown\"}\\n`);\n\n  // 2 steps for update firmware: download firmware and upload\n  try {\n    await downloadFirmware(assetName, downloadDir.name, log);\n    await upload(downloadedAsset, \"0x00010000\", portCache, log);\n    log(`${doneMessage}\\n`);\n  } catch (err) {\n    if (currentActiveProcess) {\n      console.error(\"Unable to update firmware:\", err);\n      log(`${doneWithErrorMessage}: ${err}\\n`);\n      portCache = null;\n    } else {\n      log(`${doneWithCancelledMessage}.\\n`);\n    }\n  }\n\n  // cleanup\n  currentActiveProcess = null;\n  try {\n    downloadDir.removeCallback();\n  } catch (err) {\n    // do nothing, when clean fails\n  }\n\n}\n\nasync function saveBinaryFile(filename, uint8array, log) {\n  log(`Saving poi channel data to ${filename}...`);\n  await fs.writeFile(filename, uint8array);\n  log(\"Done\\n\");\n}\n\nfunction getScriptsBaseDir() {\n  if (isDev) {\n    return process.cwd();\n  }\n\n  if (app) {\n    const exePath = app.getPath(\"exe\");\n    return path.dirname(exePath);\n  }\n\n  return process.cwd();\n}\n\nfunction getScriptsDir() {\n  const baseDir = getScriptsBaseDir();\n  const platform = process.platform;\n  const arch = process.arch;\n  return path.join(baseDir, \"resources\", platform, arch);\n}\n\nasync function mkSpiffs(dir, filename, log) {\n\n  log(`Generating spiffs image ${filename}...\\n`);\n\n  const scriptDir = getScriptsDir();\n  log(`Script path: ${scriptDir}\\n`);\n  const exe = path.join(scriptDir, \"mkspiffs\");\n  currentActiveProcess = spawn(exe, [\"-c\", dir, \"-b\", \"4096\", \"-p\", \"256\", \"-s\", \"0x2B0000\", filename]);\n\n  currentActiveProcess.stdout.on(\"data\", (data) => {\n    const str = data.toString();\n    const lines = str.split(/(\\r?\\n)/g);\n    log(lines.join(\"\\n\"));\n  });\n  currentActiveProcess.stderr.on(\"data\", (data) => {\n    const str = data.toString();\n    const lines = str.split(/(\\r?\\n)/g);\n    const logStr = lines.join(\"\\n\");\n    console.error(logStr);\n    log(`[Error] ${logStr}`);\n  });\n  currentActiveProcess.on(\"error\", (err) => {\n    console.error(err);\n    log(`[Error] ${err}`);\n  });\n  currentActiveProcess.on(\"close\", (code) => {\n    if (code > 1) {\n      log(`[Error]mkSpiffs exited with code ${code}.\\n`);\n    }\n  });\n\n  await currentActiveProcess;\n  log(\"Done generating spiffs image.\\n\");\n}\n\nasync function upload(filename, addr, port, log) {\n\n  const scriptDir = getScriptsDir();\n  log(`Script path: ${scriptDir}\\n`);\n  const exe = path.join(scriptDir, \"esptool\");\n  const params = [\"--chip\", \"esp32\", \"--baud\", \"921600\", \"write_flash\", \"-z\", addr, filename];\n\n  if (port) {\n    params.unshift(\"--port\", port);\n    log(`Uploading to port ${port}...\\n`);\n  } else {\n    log(\"Autodetecting port for upload...\\n\");\n  }\n\n  currentActiveProcess = spawn(exe, params);\n\n  currentActiveProcess.stdout.on(\"data\", (data) => {\n    // potentially update port cache\n    const m = /Serial port ([a-zA-Z0-9]+)/.exec(data);\n    if (m) {\n      portCache = m.length > 0 ? m[1] : null;\n      if (portCache) {\n        log(`\\nPort cache set to ${portCache}.\\n`);\n      }\n    }\n    const str = data.toString();\n    const lines = str.split(/(\\r?\\n)/g);\n    log(lines.join(\"\"));\n  });\n  currentActiveProcess.stderr.on(\"data\", (data) => {\n    const str = data.toString();\n    const lines = str.split(/(\\r?\\n)/g);\n    const logStr = lines.join(\"\\n\");\n    console.error(logStr);\n    log(`[Error] ${logStr}`);\n  });\n  currentActiveProcess.on(\"error\", (err) => {\n    console.error(err);\n    log(`[Error] ${err}`);\n  });\n\n  currentActiveProcess.on(\"close\", (code) => {\n    if (code > 1) {\n      log(`[Error]esptool exited with code ${code}.\\n`);\n    }\n  });\n\n  await currentActiveProcess;\n}\n\nasync function downloadFirmware(assetName, outputdir, log) {\n\n  const user = \"gmoehler\";\n  const repo = \"ledpoi\";\n  const leaveZipped = false;\n\n  // Define a function to filter releases.\n  function filterRelease(release) {\n    return release.prerelease === false;\n  }\n\n  // Define a function to filter assets.\n  function filterAsset(asset) {\n    return asset.name === assetName;\n  }\n\n  log(`Downloading firmware '${assetName}' to ${outputdir}...`);\n  try {\n    await downloadRelease(user, repo, outputdir, filterRelease, filterAsset, leaveZipped);\n  } catch (err) {\n    // not sure err is set\n    currentActiveProcess = true; // hack to show real error\n    throw err;\n  }\n\n  log(\"Done.\\n\");\n}\n\nexport function killCurrentProcess() {\n  if (currentActiveProcess) {\n    const pid = currentActiveProcess.pid;\n    kill(pid);\n    currentActiveProcess = null;\n  }\n}\n","// action type constants\n\n// channel actions\nexport const ADD_CHANNEL = \"ADD_CHANNEL\";\nexport const DELETE_CHANNEL = \"DELETE_CHANNEL\";\nexport const CLEAR_CHANNELS = \"CLEAR_CHANNELS\";\nexport const UPDATE_CHANNEL = \"UPDATE_CHANNEL\";\nexport const SET_CHANNEL_ACTIVE = \"SET_CHANNEL_ACTIVE\";\nexport const SET_CHANNEL_INACTIVE = \"SET_CHANNEL_INACTIVE\";\nexport const PLAY_CHANNELS = \"PLAY_CHANNELS\";\nexport const STOP_CHANNEL = \"STOP_CHANNEL\";\nexport const STOP_CHANNELS = \"STOP_CHANNELS\";\n\n// general entity actions\nexport const SELECT_ENTITY = \"SELECT_ENTITY\";\nexport const DESELECT_ENTITY = \"DESELECT_ENTITY\";\nexport const CLEAR_ENTITY_SELECTION = \"CLEAR_ENTITY_SELECTION\";\nexport const COPY_ENTITIES = \"COPY_ENTITIES\";\n\n// image list actions\nexport const CLEAR_IMAGELIST = \"CLEAR_IMAGELIST\";\nexport const ADD_IMAGE = \"ADD_IMAGE\";\nexport const REMOVE_IMAGE = \"REMOVE_IMAGE\";\n\n// part actions\nexport const CLEAR_PARTS = \"CLEAR_PARTS\";\nexport const ADD_PART = \"ADD_PART\";\nexport const DELETE_PART = \"DELETE_PART\";\nexport const MOVE_PART = \"MOVE_PART\";\nexport const MOVE_PARTS = \"MOVE_PARTS\";\nexport const RESIZE_PART = \"RESIZE_PART\";\n\n// marker actions\nexport const CLEAR_MARKERS = \"CLEAR_MARKERS\";\nexport const SET_OR_REPLACE_MARKER = \"SET_OR_REPLACE_MARKER\";\nexport const DELETE_MARKER = \"DELETE_MARKER\";\nexport const UPDATE_MARKER = \"UPDATE_MARKER\";\n\n// io actions\nexport const LOAD_SHOW_STARTED = \"LOAD_SHOW_STARTED\";\nexport const LOAD_SHOW_SUCCESS = \"LOAD_SHOW_SUCCESS\";\nexport const LOAD_SHOW_FAILURE = \"LOAD_SHOW_FAILURE\";\n\nexport const LOAD_AUDIO_STARTED = \"LOAD_AUDIO_STARTED\";\nexport const LOAD_AUDIO_SUCCESS = \"LOAD_AUDIO_SUCCESS\";\nexport const LOAD_AUDIO_FAILURE = \"LOAD_AUDIO_FAILURE\";\n\nexport const INIT_LOAD_PROGRESS = \"INIT_LOAD_PROGRESS\";\nexport const SET_LOAD_PROGRESS = \"SET_LOAD_PROGRESS\";\nexport const INCR_LOAD_PROGRESS = \"INCR_LOAD_PROGRESS;\";\n\n// view actions\nexport const CLEAR_VIEW = \"CLEAR_VIEW\";\nexport const SELECT_RANGE = \"SELECT_RANGE\";\nexport const DESELECT_RANGE = \"DESELECT_RANGE\";\nexport const SET_RESOLUTION = \"SET_RESOLUTION\";\nexport const SET_CHANNEL_PLAY_STATE = \"SET_CHANNEL_PLAY_STATE\";\n\nexport const SELECT_IMAGE_CHANNEL = \"SELECT_IMAGE_CHANNEL\";\nexport const ADD_TO_UPLOAD_LOG = \"ADD_TO_UPLOAD_LOG\";\nexport const CLEAR_UPLOAD_LOG = \"CLEAR_UPLOAD_LOG\";\nexport const SET_MESSAGE = \"SET_MESSAGE\";\nexport const CLEAR_MESSAGE = \"CLEAR_MESSAGE\";\n\nexport const TOGGLE_SNAP_TO_MARKER = \"TOGGLE_SNAP_TO_MARKER\";","\nimport {\n  CLEAR_VIEW, LOAD_SHOW_STARTED, LOAD_SHOW_SUCCESS, LOAD_SHOW_FAILURE,\n  SELECT_RANGE, DESELECT_RANGE, SET_RESOLUTION, SELECT_IMAGE_CHANNEL,\n  ADD_TO_UPLOAD_LOG, CLEAR_UPLOAD_LOG, SET_MESSAGE, CLEAR_MESSAGE, SET_LOAD_PROGRESS,\n  INCR_LOAD_PROGRESS, INIT_LOAD_PROGRESS, TOGGLE_SNAP_TO_MARKER\n} from \"../actions/types\";\n\n// export for tests\nexport const initialState = {\n  selection: {\n    from: null,\n    to: null,\n    type: null,\n  },\n  resolution: 80,\n  selectedImageChannelId: null,\n  partsToCopy: null,\n  uploadLog: null,\n  loadShowStatus: null,\n  message: null,\n  loadProgress: {\n    base: 100,\n    progress: 0\n  },\n  snapToMarkers: true,\n};\n\n\n/* eslint import/no-anonymous-default-export: [2, {\"allowArrowFunction\": true}] */\nexport default (state = initialState, action) => {\n  switch (action.type) {\n\n    case CLEAR_VIEW:\n      return initialState;\n\n    case LOAD_SHOW_STARTED:\n      return {\n        ...state,\n        loadShowStatus: \"started\"\n      };\n\n    case LOAD_SHOW_SUCCESS:\n      return {\n        ...state,\n        loadShowStatus: \"success\"\n      };\n\n    case LOAD_SHOW_FAILURE:\n      return {\n        ...state,\n        loadShowStatus: \"failure\"\n      };\n\n    case INIT_LOAD_PROGRESS:\n      return {\n        ...state,\n        loadProgress: {\n          base: action.payload || 100,\n          progress: 0,\n        }\n      };\n\n    case SET_LOAD_PROGRESS:\n      return {\n        ...state,\n        loadProgress: {\n          ...state.loadProgress,\n          progress: action.payload,\n        }\n      };\n\n    case INCR_LOAD_PROGRESS:\n      const incr = action.payload || 1;\n      const updatedProgress = state.loadProgress.progress + incr;\n      return {\n        ...state,\n        loadProgress: {\n          ...state.loadProgress,\n          progress: updatedProgress > state.loadProgress.base ? state.loadProgress.base : updatedProgress,\n        }\n      };\n\n    case SELECT_RANGE:\n      return {\n        ...state,\n        selection: {\n          from: action.payload.from,\n          to: action.payload.to,\n          type: action.payload.type\n        }\n      };\n\n    case DESELECT_RANGE:\n      return {\n        ...state,\n        selection: {\n          from: null,\n          to: null,\n          type: null,\n        }\n      };\n\n    case SELECT_IMAGE_CHANNEL:\n      return {\n        ...state,\n        selectedImageChannelId: action.payload\n      };\n\n    case SET_RESOLUTION:\n      return {\n        ...state,\n        resolution: action.payload\n      };\n\n    case ADD_TO_UPLOAD_LOG:\n      return {\n        ...state,\n        uploadLog: state.uploadLog ? state.uploadLog + action.payload : action.payload\n      };\n\n    case CLEAR_UPLOAD_LOG:\n      return {\n        ...state,\n        uploadLog: null\n      };\n\n    case SET_MESSAGE:\n      return {\n        ...state,\n        message: action.payload\n      };\n\n    case CLEAR_MESSAGE:\n      return {\n        ...state,\n        message: null\n      };\n\n    case TOGGLE_SNAP_TO_MARKER:\n      return {\n        ...state,\n        snapToMarkers: !state.snapToMarkers,\n      };\n\n\n    default:\n      return state;\n  }\n};\n\nexport const getSelectionRange = (state) => {\n  return {\n    from: state.view.selection.from,\n    to: state.view.selection.to,\n    type: state.view.selection.type,\n  };\n};\n\nexport const getResolution = (state) => {\n  return state.view.resolution;\n};\n\nexport const getPartsToCopy = (state) => {\n  return state.view.partsToCopy;\n};\n\nexport const getSelectedImageChannelId = (state) => state.view.selectedImageChannelId;\n\nexport const getUploadLog = (state) => state.view.uploadLog;\n\nexport const getMessage = (state) => state.view.message;\n\nexport const isLoadingShow = (state) => {\n  return state.view.loadShowStatus === \"started\";\n};\n\nexport const getLoadProgressInPercent = (state) => {\n  return 100.0 * state.view.loadProgress.progress / state.view.loadProgress.base;\n};\n\nexport const getSnapToMarkers = (state) => {\n  return state.view.snapToMarkers;\n};\n","import { cloneDeep } from \"lodash\";\nimport {\n  CLEAR_IMAGELIST, ADD_IMAGE, REMOVE_IMAGE,\n} from \"../actions/types\";\nimport { combineReducers } from \"redux\";\n\nexport const initialState = {\n  byImageId: {},\n  allImageIds: [],\n};\n\nconst byImageId = (state = {}, action) => {\n  switch (action.type) {\n\n    case CLEAR_IMAGELIST:\n      return {};\n\n    case ADD_IMAGE:\n      return {\n        ...state,\n        [action.payload.imageId]: action.payload\n      };\n\n    case REMOVE_IMAGE:\n      const newByImageId = cloneDeep(state);\n      delete newByImageId[action.payload];\n      return newByImageId;\n\n    default:\n      return state;\n  }\n};\n\nconst allImageIds = (state = [], action) => {\n  switch (action.type) {\n\n    case CLEAR_IMAGELIST:\n      return [];\n\n    case ADD_IMAGE:\n      // we already ensured in the action that it did not yet exist\n      return [...state, action.payload.imageId];\n\n    case REMOVE_IMAGE:\n      return state.filter(p => p !== action.payload);\n\n    default:\n      return state;\n  }\n};\n\nexport default combineReducers({\n  byImageId,\n  allImageIds,\n});\n\nexport const getImages = (state) => {\n  return state.entities.images.byImageId;\n};\n\nexport const getImageList = (state) => {\n  return Object.values(state.entities.images.byImageId);\n};\n\n// TODO: move sample rate to part\nexport const getImageSampleRate = (state) => {\n  return state.entities.images.sampleRate;\n};\n\n// TODO: move image duration to part\nexport const getImageDuration = (state, imageId) => {\n  const img = state.entities.images.byImageId[imageId];\n  return img ? img.duration : 0;\n};\n\nexport const imageExists = (state, id) =>\n  state.entities.images.allImageIds.includes(id);\n","// reducer working on the part entities\n\nimport { combineReducers } from \"redux\";\nimport { schema, denormalize } from \"normalizr\";\n\nimport {\n  CLEAR_PARTS, ADD_PART, DELETE_PART, MOVE_PART, RESIZE_PART, MOVE_PARTS,\n} from \"../actions/types\";\nimport { cloneDeep } from \"lodash\";\n\nexport const partSchema = new schema.Entity(\n  \"byPartId\",\n  {},\n  { idAttribute: \"partId\" }\n);\n\nexport const initialState = {\n  byPartId: {},\n  allPartIds: [],\n};\n\n// split into 2 reducers: byPartId and allPartIds\n\nconst byPartId = (state = {}, action) => {\n  switch (action.type) {\n\n    case ADD_PART: {\n      return {\n        ...state,\n        ...action.payload.entities.byPartId, // normalized parts\n      };\n    }\n    case MOVE_PART:\n      const part0 = state[action.payload.partId];\n      const currentOffset0 = part0.actOffset || part0.offset || 0;\n      const partUpdate0 = movePartWithSnap(\n        currentOffset0, part0.duration,\n        action.payload.incr, action.payload.snapPositions,\n        action.payload.snapDist);\n\n      const newPart0 = {\n        ...part0,\n        ...partUpdate0\n      };\n      return {\n        ...state,\n        [action.payload.partId]: newPart0,\n      };\n\n    case MOVE_PARTS:\n      const incr = getIncrWithSnap(action.payload.partIds, state,\n        action.payload.incr, action.payload.snapPositions, action.payload.snapDist);\n\n      // update offset\n      // actOffset keeps going independent of snap\n      const newByPartId = cloneDeep(state);\n      action.payload.partIds.forEach((partId) => {\n        // no updates when incr is null (we are crossing 0)\n        if (incr !== null) {\n          const part = state[partId];\n          const offset = part.offset + incr;\n          const actOffset = (part.actOffset || part.offset) + action.payload.incr;\n\n          newByPartId[part.partId] = {\n            ...part,\n            offset,\n            actOffset,\n          };\n        }\n      });\n\n      return {\n        ...newByPartId\n      };\n\n    case RESIZE_PART:\n      const part1 = state[action.payload.partId];\n      const snapDist1 = action.payload.snapDist || 0.2;\n      const minDur1 = action.payload.minDuration; // min part duration\n      const snapPositions1 = action.payload.snapPositions;\n      let newPart1;\n\n      // left part boundary moved\n      if (action.payload.bound === \"left\") {\n        const rightBound1 = part1.offset + part1.duration;\n        const currentOffset1 = part1.actOffset || part1.offset || 0;\n        const actualOffset1 = bound(currentOffset1 + action.payload.incr, 0, rightBound1 - minDur1);\n        const snapOffsetLeft1 = snapTo(actualOffset1, snapPositions1, snapDist1);\n        const updatedOffset1 = bound(snapOffsetLeft1, 0, rightBound1 - minDur1);\n\n        newPart1 = {\n          ...part1,\n          offset: updatedOffset1,\n          duration: rightBound1 - updatedOffset1,\n          actOffset: actualOffset1,\n          actRightBound: null,\n        };\n\n      } else {\n        // right part bound moved\n        const rightBound2 = part1.actRightBound || (part1.offset + part1.duration);\n        const actualRightBound2 = bound(rightBound2 + action.payload.incr, part1.offset + minDur1, null);\n        const snapOffsetRight2 = snapTo(actualRightBound2, snapPositions1, snapDist1);\n        const updatedDuration2 = bound(snapOffsetRight2 - part1.offset, minDur1, null);\n\n        newPart1 = {\n          ...part1,\n          duration: updatedDuration2,\n          offset: part1.offset,\n          actRightBound: actualRightBound2,\n          actOffset: null,\n        };\n      }\n\n      return {\n        ...state,\n        [action.payload.partId]: newPart1,\n      };\n\n    case DELETE_PART:\n      const newState = {\n        ...state\n      };\n      delete newState[action.payload.partId]; // ids\n      return newState;\n\n    case CLEAR_PARTS:\n      return {};\n\n    default:\n      return state;\n  }\n};\n\nconst allPartIds = (state = [], action) => {\n  switch (action.type) {\n\n    case ADD_PART:\n      return [...state, action.payload.result];\n\n    case DELETE_PART:\n      return state.filter(p => p !== action.payload.partId);\n\n    case CLEAR_PARTS:\n      return [];\n\n    default:\n      return state;\n  }\n};\n\nexport default combineReducers({\n  byPartId,\n  allPartIds,\n});\n\n// calc one increment for all parts, which depends on snap of\n// first and last part\nfunction getIncrWithSnap(partIdsToMove, partsById, incr, snapPositions, snapDist) {\n  // find index of left most and right most part\n  const [minId, maxId] = partIdsToMove.reduce(([minId, maxId], partId) => {\n    if (minId === null || maxId === null) {\n      return [partId, partId];\n    }\n    const part = partsById[partId];\n    if (part.offset < partsById[minId].offset) {\n      return [part.partId, maxId];\n    }\n    if (part.offset + part.duration > partsById[minId].offset + partsById[minId].duration) {\n      return [minId, part.partId];\n    }\n    return [minId, maxId];\n  }, [null, null]);\n\n  let updatedOffset = (partsById[minId].actOffset || partsById[minId].offset) + incr;\n\n  let updatedIncr = incr;\n  // potentially snap left to next snap position\n  const snapOffsetLeft = snapTo(updatedOffset, snapPositions, snapDist);\n  if (snapOffsetLeft !== updatedOffset) {\n    // ok we snapped to the left, recalc incr\n    updatedIncr = snapOffsetLeft - partsById[minId].offset;\n  } else {\n    // try to snap at the right\n    const updatedOffsetRight = (partsById[maxId].actOffset || partsById[maxId].offset)\n      + partsById[maxId].duration + incr;\n    const snapOffsetRight = snapTo(updatedOffsetRight, snapPositions, snapDist);\n    updatedIncr = snapOffsetRight - (partsById[maxId].offset + partsById[maxId].duration);\n  }\n\n  if (partsById[minId].offset + updatedIncr < 0) {\n    // special value to signalize that actOffset should not be changed\n    updatedIncr = null;\n  }\n\n  return updatedIncr;\n}\n\nfunction movePartWithSnap(offset, duration, incr, snapPositions, snapDist) {\n  // actOffset is the actuall offset without snap\n  const updatedOffset = (offset + incr < 0) ? 0 : offset + incr;\n\n  // potentially snap left to next snap position\n  const snapOffsetLeft = snapTo(updatedOffset, snapPositions, snapDist);\n  // only snap right when left was not snapped yet\n  const snapOffsetRight = (snapOffsetLeft === updatedOffset)\n    ? snapTo(updatedOffset + duration, snapPositions, snapDist)\n    : snapOffsetLeft + duration;\n\n  return {\n    offset: (snapOffsetRight - duration < 0) ? 0 : snapOffsetRight - duration,\n    duration,\n    actOffset: updatedOffset,\n    actRightBound: null,\n  };\n}\n\nfunction bound(val, leftBound, rightBound) {\n  let left = leftBound;\n  if (rightBound) {\n    const right = Math.max(leftBound, rightBound);\n    left = Math.min(leftBound, rightBound);\n    if (val > right) {\n      return right;\n    }\n  }\n\n  return Math.max(val, left);\n}\n\nfunction snapTo(posToSnap, snapPositions, maxDist) {\n  const snapDiffLeft = closestSnapDiff(posToSnap, snapPositions);\n  if (Number.isInteger(snapDiffLeft.idx) && snapDiffLeft.diff < maxDist) {\n    return snapPositions[snapDiffLeft.idx]; // snap\n  }\n  return posToSnap;\n}\n\n// export for testing only\nexport function closestSnapDiff(myPos, snapPositions) {\n  const diffs = snapPositions ? snapPositions\n    .map((pos) => Math.abs(pos - myPos)) : [];\n  const idx = diffs\n    .reduce((iMin, val, i, dif) =>\n      (Number.isInteger(iMin) && val >= dif[iMin]) ? iMin : i, null);\n\n  if (Number.isInteger(idx)) {\n    return {\n      idx,\n      diff: diffs[idx]\n    };\n  }\n  return {\n    idx,\n    diff: null\n  };\n\n}\n\nexport function partExists(state, partId) {\n  return state.entities.parts.allPartIds.includes(partId);\n}\n\nexport function getPart(state, partId) {\n  return state.entities.parts.byPartId[partId];\n}\n\nexport function getParts(state, partIds) {\n  return denormalize(partIds, [partSchema], state.entities.parts);\n}\n\nexport function getAllPartIds(state) {\n  return state.entities.parts.allPartIds;\n}\n\nexport function getChannelId(state, partId) {\n  if (!partExists(state, partId)) {\n    return null;\n  }\n  return getPart(state, partId).channelId;\n}\n\nexport const getPartIdsInInterval = (state, channelId, from, to) => {\n  // from channel only\n  // const partIds = getPartIdsInChannel(state, channelId);\n  // or all parts\n  const partIds = getAllPartIds(state);\n  const parts = getParts(state, partIds);\n  return parts\n    .filter(\n      part => part.offset + part.duration < to && part.offset > from)\n    .map(part => part.partId);\n};","// reducer working on the part entities\n\nimport { combineReducers } from \"redux\";\nimport { denormalize, schema } from \"normalizr\";\n\nimport { ADD_CHANNEL, DELETE_CHANNEL, CLEAR_CHANNELS, SET_CHANNEL_INACTIVE, PLAY_CHANNELS, STOP_CHANNELS, STOP_CHANNEL, SET_CHANNEL_ACTIVE, ADD_PART, UPDATE_CHANNEL, DELETE_PART } from \"../actions/types\";\nimport { partSchema, getParts, } from \"./partReducer\";\nimport { getSelectedImageChannelId } from \"./viewReducer\";\n\n// schemata for normalization\n\nexport const achannelSchema = new schema.Entity(\n  \"byChannelId\",\n  { parts: [partSchema] },\n  { idAttribute: \"channelId\" }\n);\nexport const thechannelsSchema = [achannelSchema];\n\nexport const initialState = {\n  byChannelId: {},\n  allChannelIds: [],\n  activeChannels: [],\n  playingChannels: [],\n};\n\n// split into multiple reducers\n\nconst byChannelId = (state = {}, action) => {\n  switch (action.type) {\n\n    case ADD_CHANNEL: {\n      return {\n        ...state,\n        ...action.payload.entities.byChannelId, // normalized channels\n      };\n    }\n    case DELETE_CHANNEL:\n      const newState = {\n        ...state\n      };\n      delete newState[action.payload];\n      return newState;\n\n    case CLEAR_CHANNELS:\n      return {};\n\n    case ADD_PART:\n      //TODO: add test\n      const partId0 = action.payload.result;\n      const part0 = action.payload.entities.byPartId[partId0];\n      const channel0 = {\n        ...state[part0.channelId]\n      };\n      if (!channel0) {\n        return state;\n      }\n      const parts0 = [\n        ...channel0.parts,\n        partId0, // add new partId\n      ];\n      // and adjust duration\n      const duration0 = Math.max(channel0.duration, part0.offset + part0.duration);\n      return {\n        ...state,\n        [part0.channelId]: {\n          ...channel0,\n          parts: parts0,\n          duration: duration0,\n        }\n      };\n\n    case DELETE_PART:\n      //TODO: add test\n      const partId2 = action.payload.partId;\n      const channelId2 = action.payload.channelId;\n      const channel2 = {\n        ...state[channelId2]\n      };\n      const parts2 = channel2.parts.filter(p => p !== partId2);\n      // TODO: adjust duration\n      return {\n        ...state,\n        [channelId2]: {\n          ...channel2,\n          parts: parts2,\n        }\n      };\n\n    case UPDATE_CHANNEL:\n      const channelId1 = action.payload.channelId;\n      const channel1 = {\n        ...state[channelId1]\n      };\n      return {\n        ...state,\n        [channelId1]: {\n          ...channel1,\n          ...action.payload\n        }\n      };\n\n    default:\n      return state;\n  }\n};\n\nconst allChannelIds = (state = [], action) => {\n  switch (action.type) {\n\n    case ADD_CHANNEL:\n      return [...state, action.payload.result];\n\n    case DELETE_CHANNEL:\n      return state.filter(p => p !== action.payload);\n\n    case CLEAR_CHANNELS:\n      return [];\n\n    default:\n      return state;\n  }\n};\n\nconst activeChannels = (state = [], action) => {\n  switch (action.type) {\n\n    case SET_CHANNEL_ACTIVE:\n      return [...state, action.payload];\n\n    case DELETE_CHANNEL:\n    case SET_CHANNEL_INACTIVE:\n      return state.filter(p => p !== action.payload);\n\n    case CLEAR_CHANNELS:\n      return [];\n\n    default:\n      return state;\n  }\n};\n\nconst playingChannels = (state = [], action) => {\n  switch (action.type) {\n\n    case PLAY_CHANNELS:\n      return [...state, ...action.payload];\n\n    case DELETE_CHANNEL:\n    case STOP_CHANNEL:\n      return state.filter(p => p !== action.payload);\n\n    case CLEAR_CHANNELS:\n    case STOP_CHANNELS:\n      return [];\n\n    default:\n      return state;\n  }\n};\n\nexport default combineReducers({\n  byChannelId,\n  allChannelIds,\n  activeChannels,\n  playingChannels\n});\n\n// selectors\n\nexport function getAllChannelIds(state) {\n  return state.entities.channels.allChannelIds\n    .sort((chId1, chId2) => {\n      // return audio channels first\n      return chId1.localeCompare(chId2);\n    });\n}\n\nexport function channelExists(state, channelId) {\n  return getAllChannelIds(state).includes(channelId);\n}\n\nexport function isChannelPlaying(state, channelId) {\n  return state.entities.channels.playingChannels.includes(channelId);\n}\n\nexport function isChannelActive(state, channelId) {\n  return state.entities.channels.activeChannels.includes(channelId);\n}\n\nexport function getNumChannels(state) {\n  return getAllChannelIds(state).length;\n}\n\nexport function allChannelsStopped(state) {\n  return state.entities.channels.playingChannels.length === 0;\n}\n\nexport function getActiveChannelIds(state, type) {\n  const activeChannelIds = state.entities.channels.activeChannels;\n  if (!type) {\n    return activeChannelIds;\n  }\n  const activeChannelIdsOfType = activeChannelIds.filter((channelId) =>\n    _getChannelType(state, channelId) === type);\n  return activeChannelIdsOfType;\n}\n\nfunction _getChannel(state, channelId) {\n  if (!channelExists(state, channelId)) {\n    return null;\n  }\n  return state.entities.channels.byChannelId[channelId];\n}\n\nfunction _getChannelType(state, channelId) {\n  const ch = _getChannel(state, channelId);\n  return ch ? ch.type : 0;\n}\n\nfunction _getChannelDuration(state, channelId) {\n  const ch = _getChannel(state, channelId);\n  return ch ? ch.duration : 0;\n}\n\nexport function getChannelGain(state, channelId) {\n  const ch = _getChannel(state, channelId);\n  return ch ? ch.gain : 0;\n}\n\nexport function getChannelSampleRate(state, channelId) {\n  const ch = _getChannel(state, channelId);\n  return ch ? ch.sampleRate : 0;\n}\n\nexport function getChannelMinPartDuration(state, channelId) {\n  const ch = _getChannel(state, channelId);\n  return ch ? ch.minPartDuration : 0;\n}\n\nexport function getChannelSnapDist(state, channelId) {\n  const ch = _getChannel(state, channelId);\n  return ch ? ch.snapDist : 0;\n}\n\nexport function getChannelPartIds(state, channelId) {\n  const ch = _getChannel(state, channelId);\n  return ch ? ch.parts : 0;\n}\n\nexport function getChannelParts(state, channelId) {\n  const ch = _getChannel(state, channelId);\n  return ch ? getParts(state, ch.parts) : [];\n}\n\n// get the subpart of the channel that is needed for the channel display\nexport function getChannelData(state, channelId) {\n\n  const { type, sampleRate, duration, parts, buffer, ...remainingObj } = _getChannel(state, channelId); // eslint-disable-line no-unused-vars\n  const active = isChannelActive(state, channelId);\n  const selected = getSelectedImageChannelId(state) === channelId;\n  return {\n    channelId, type, active, sampleRate, duration,\n    parts, selected, buffer\n  };\n}\n\n// get the subpart of the channel that is needed for the channel selector\nexport function getChannelSelectorData(state, channelId) {\n  // eslint-disable-next-line no-unused-vars\n  const { type, gain, ...remainingObj } = _getChannel(state, channelId);\n  const active = isChannelActive(state, channelId);\n  const selected = getSelectedImageChannelId(state) === channelId;\n  return {\n    channelId, type, gain, active, selected\n  };\n}\n\nexport const getMaxChannelDuration = state => (getNumChannels(state) === 0 ?\n  0 : state.entities.channels.allChannelIds\n    .reduce((duration, channeld) => Math.max(duration, _getChannelDuration(state, channeld)), 0));\n\nexport const getDenormalizedChannel0 = (state, channelId) => {\n  const channel = _getChannel(state, channelId);\n  return channel ? denormalize(channel, achannelSchema, state.entities.parts) : null;\n};\n\nfunction _getEntities(state) {\n  return {\n    byChannelId: state.entities.channels.byChannelId,\n    byPartId: state.entities.parts.byPartId,\n    byImageId: state.entities.parts.byImageId,\n  };\n}\n\nexport const getDenormalizedChannel = (state, channelId) => {\n  return channelExists(state, channelId) ?\n    denormalize(channelId, achannelSchema, _getEntities(state)) : null;\n};\n\nexport const getAllDenormalizedChannels = (state) => {\n  return denormalize(getAllChannelIds(state), thechannelsSchema, _getEntities(state));\n};\n","import { cloneDeep, omit } from \"lodash\";\nimport { CLEAR_MARKERS, SET_OR_REPLACE_MARKER, DELETE_MARKER, UPDATE_MARKER, } from \"../actions/types\";\nimport { combineReducers } from \"redux\";\n\nexport const initialState = {\n  byMarkerId: {},\n  allMarkerIds: []\n};\n\nconst byMarkerId = (state = {}, action) => {\n  switch (action.type) {\n\n    case CLEAR_MARKERS:\n      return {};\n\n    case SET_OR_REPLACE_MARKER:\n      return {\n        ...state,\n        [action.payload.markerId]: action.payload\n      };\n\n    case DELETE_MARKER:\n      const newByMarkerId = cloneDeep(state);\n      delete newByMarkerId[action.payload];\n      return newByMarkerId;\n\n    case UPDATE_MARKER:\n      // update marker type, and pos by either incr or pos\n      // expecting markerId, and incr or pos or type\n      // if marker does not yet exist: do nothing\n      const prevMarker = state[action.payload.markerId];\n      let pos = prevMarker.pos;\n      if (action.payload.incr) {\n        pos = Math.max(0, prevMarker.pos + action.payload.incr);\n      } else if (typeof action.payload.pos == \"number\") {\n        pos = action.payload.pos;\n      }\n      const type = action.payload.type || prevMarker.type;\n      return {\n        ...state,\n        [action.payload.markerId]: {\n          ...prevMarker,\n          pos,\n          type\n        }\n      };\n\n    default:\n      return state;\n  }\n};\n\nconst allMarkerIds = (state = [], action) => {\n  switch (action.type) {\n\n    case CLEAR_MARKERS:\n      return [];\n\n    case SET_OR_REPLACE_MARKER:\n      return state.includes(action.payload.markerId) ?\n        state : [...state, action.payload.markerId];\n\n    case DELETE_MARKER:\n      return state.filter(p => p !== action.payload);\n\n    case UPDATE_MARKER:\n      return state;\n\n    default:\n      return state;\n  }\n};\n\nexport default combineReducers({\n  byMarkerId,\n  allMarkerIds,\n});\n\nexport const getAllMarkers = (state) => {\n  return Object.values(state.entities.markers.byMarkerId);\n};\n\nexport const getAllMarkerIds = (state) => {\n  return state.entities.markers.allMarkerIds\n    .sort((mId1, mId2) => {\n      // insert markers first (first letter 'i' vs 'p' / 't')\n      // so that existing markers are above the insert marker\n      return mId1.localeCompare(mId2);\n    });;\n};\n\nexport const getAllMarkerPosOfType = (state, type) => {\n  return Object.values(state.entities.markers.byMarkerId)\n    .filter((marker) => marker.type === type)\n    .map((marker) => marker.pos)\n    .sort();\n};\n\n// for file export\nexport const getAllMarkersOfType = (state, type) => {\n  return Object.values(state.entities.markers.byMarkerId)\n    .filter((marker) => marker.type === type)\n    .map((marker) => omit(marker, [\"markerId\"]));\n};\n\nexport const getMarker = (state, markerId) => {\n  return state.entities.markers.byMarkerId[markerId];\n};\n\nexport const markerExists = (state, id) =>\n  state.entities.markers.allMarkerIds.includes(id);","\nimport { combineReducers } from \"redux\";\n\nimport {\n  SELECT_ENTITY, DESELECT_ENTITY, CLEAR_ENTITY_SELECTION,\n  DELETE_PART, CLEAR_PARTS, REMOVE_IMAGE, CLEAR_IMAGELIST, COPY_ENTITIES\n} from \"../actions/types\";\n\nimport imageListReducer, { imageExists, initialState as initialImageListState } from \"./imageListReducer\";\nimport channelReducer, { channelExists, initialState as initialChannelState } from \"./channelReducer\";\nimport partReducer, { partExists, initialState as initialPartState } from \"./partReducer\";\nimport markerReducer, { markerExists, initialState as initialMarkerState } from \"./markerReducer\";\n\nexport const initialState = {\n  images: initialImageListState,\n  channels: initialChannelState,\n  parts: initialPartState,\n  markers: initialMarkerState,\n  selectedEntityIds: [],\n  entityIdsToCopy: [],\n};\n\nconst selectedEntityIds = (state = [], action) => {\n  switch (action.type) {\n\n    case SELECT_ENTITY:\n      return [...state, action.payload];\n\n    case DESELECT_ENTITY:\n      return state.filter(p => p !== action.payload);\n\n    case CLEAR_ENTITY_SELECTION:\n    case CLEAR_IMAGELIST:\n    case CLEAR_PARTS:\n      return [];\n\n    case DELETE_PART:\n      return state.filter(p => p !== action.payload.partId);\n\n    case REMOVE_IMAGE:\n      return state.filter(p => p !== action.payload);\n\n    default:\n      return state;\n  }\n};\n\nconst entityIdsToCopy = (state = [], action) => {\n  switch (action.type) {\n\n    case COPY_ENTITIES:\n      return [...action.payload];\n\n    default:\n      return state;\n  }\n};\n\nexport default combineReducers({\n  parts: partReducer,\n  images: imageListReducer,\n  markers: markerReducer,\n  channels: channelReducer,\n  selectedEntityIds,\n  entityIdsToCopy,\n});\n\nexport function entityExists(state, entityId) {\n  return state.entities.images.allImageIds.includes(entityId) ||\n    state.entities.parts.allPartIds.includes(entityId);\n}\n\nexport function isEntitySelected(state, entityId) {\n  return state.entities.selectedEntityIds.includes(entityId);\n}\n\nexport function isEntitySingleSelected(state, entityId) {\n  return state.entities.selectedEntityIds === [entityId];\n}\n\nexport function getEntityType(state, entityId) {\n  if (partExists(state, entityId)) {\n    return \"part\";\n  } else if (imageExists(state, entityId)) {\n    return \"image\";\n  } else if (markerExists(state, entityId)) {\n    return \"marker\";\n  } else if (channelExists(state, entityId)) {\n    return \"channel\";\n  }\n  return \"unknown\";\n}\n\nexport function isEntitySelectable(state, entityId) {\n  return [\"part\", \"image\"].includes(getEntityType(state, entityId));\n}\n\n// only one type of entities can be selected \n// currently only part or image\nexport function getSelectedEntityType(state) {\n  if (state.entities.selectedEntityIds.length === 0) {\n    return \"none\";\n  }\n  return getEntityType(state, state.entities.selectedEntityIds[0]);\n}\n\nexport function getSelectedEntityIds(state) {\n  return state.entities.selectedEntityIds;\n}\n\nexport function getSelectedEntityIdsOfType(state, type) {\n  return getSelectedEntityType(state) === type ?\n    getSelectedEntityIds(state) : [];\n}\n\nexport function anyEntitySelected(state) {\n  return getSelectedEntityIds(state).length > 0;\n}\n\nexport function getEntitiesIdsToCopy(state) {\n  return state.entities.entityIdsToCopy;\n}","import { combineReducers } from \"redux\";\r\n\r\nimport viewReducer from \"./viewReducer\";\r\nimport entityReducer from \"./entityReducer\";\r\n\r\nexport default combineReducers({\r\n    view: viewReducer,\r\n    entities: entityReducer,\r\n});\r\n","import { createStore, applyMiddleware, compose } from \"redux\";\nimport thunk from \"redux-thunk\";\nimport rootReducer from \"./reducers/rootReducer\";\n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\n\nexport default function configureStore(initialState = {}) {\n  return createStore(\n    rootReducer, initialState,\n    composeEnhancers(applyMiddleware(thunk))\n  );\n}","import React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport { withStyles } from \"@material-ui/core/styles\";\nimport { Tooltip, IconButton } from \"@material-ui/core\";\nimport { ContentCopy, ContentPaste } from \"mdi-material-ui\";\n\nimport PlaylistAddIcon from \"@material-ui/icons/PlaylistAdd\";\nimport DeleteIcon from \"@material-ui/icons/Delete\";\nimport SaveShowIcon from \"@material-ui/icons/SaveAlt\";\nimport LoadShowIcon from \"@material-ui/icons/OpenInBrowser\";\nimport UploadAudioChannelIcon from \"@material-ui/icons/QueueMusic\";\nimport ZoomInIcon from \"@material-ui/icons/ZoomIn\";\nimport ZoomOutIcon from \"@material-ui/icons/ZoomOut\";\nimport PlayArrowIcon from \"@material-ui/icons/PlayArrow\";\nimport StopIcon from \"@material-ui/icons/Stop\";\nimport Autorenew from \"@material-ui/icons/Autorenew\";\n\nconst styles = theme => ({\n  root: {\n    color: \"white\",\n  },\n  wrapper: {\n    display: \"flex\",\n    justifyContent: \"center\",\n    flexDirection: \"row\",\n    margin: 0,\n    padding: \"0 30px\",\n    whiteSpace: \"nowrap\",\n  },\n  headergroup: {\n    display: \"flex\",\n    justifyContent: \"center\",\n    flexDirection: \"row\",\n    margin: \"0 10px\",\n  },\n});\n\nexport class Header extends Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      channelId: \"\",\n    };\n  }\n\n  componentDidUpdate() {\n    if (this.state.channelId && !this.props.channelIds.includes(this.state.channelId)) {\n      this.setState({\n        channelId: this.props.channelIds[0]\n      });\n    }\n  }\n\n  loadShowFromFile = (evt) => {\n    evt.preventDefault();\n    this.props.loadShowFromFile(evt.target.files[0]);\n  };\n\n  loadAudioFromFile = (evt) => {\n    evt.preventDefault();\n    this.props.loadAudioFromFile(evt.target.files[0]);\n  };\n\n  handleChannelSelectionChange = event => {\n    const channelId = event.target.value;\n    if (this.state[event.target.name]) {\n      this.props.setChannelInactive(this.state[event.target.name]);\n    }\n    this.props.setChannelActive(channelId);\n    this.setState({\n      [event.target.name]: channelId\n    });\n  };\n\n\n  render() {\n\n    const { classes,\n      createImageChannel, saveShow, enablePlay, playChannelAndImage, enableStop,\n      stopChannel, zoomIn, zoomOut, entitySelected, deleteSelectedEntities,\n      copyParts, pasteParts, hasPartsToCopy, updateFirmware } = this.props;\n\n    return (\n      <div className={ classes.wrapper }>\n        <div className={ classes.headergroup }>\n\n          <Tooltip title=\"Load audio\">\n            <IconButton color=\"inherit\"\n              onClick={ () => {\n                /* reset input to allow re-loading */\n                this.fileUpload.value = \"\";\n                this.fileUpload.click();\n              } }>\n              <UploadAudioChannelIcon />\n            </IconButton>\n          </Tooltip>\n          <input type=\"file\"\n            accept=\"audio/*\"\n            hidden\n            ref={ (fileUpload) => this.fileUpload = fileUpload }\n            onChange={ this.loadAudioFromFile }\n            width={ 0 } />\n\n          <Tooltip title=\"Add image channel\">\n            <IconButton color=\"inherit\"\n              onClick={ createImageChannel }>\n              <PlaylistAddIcon />\n            </IconButton>\n          </Tooltip>\n\n          <Tooltip title=\"Load show\">\n            <IconButton color=\"inherit\"\n              onClick={ () => this.loadShow.click() }>\n              <LoadShowIcon />\n            </IconButton>\n          </Tooltip>\n          <input type=\"file\"\n            hidden\n            value=\"\"\n            ref={ (loadShow) => this.loadShow = loadShow }\n            onChange={ this.loadShowFromFile }\n            width={ 0 } />\n\n          <Tooltip title=\"Save show\">\n            <IconButton color=\"inherit\"\n              onClick={ saveShow }>\n              <SaveShowIcon />\n            </IconButton>\n          </Tooltip>\n        </div>\n        <div className={ classes.headergroup }>\n          <Tooltip title=\"Play\">\n            <div>\n              <IconButton color=\"inherit\"\n                disabled={ !enablePlay }\n                onClick={ () => playChannelAndImage(this.state.channelId) }>\n                <PlayArrowIcon />\n              </IconButton>\n            </div>\n          </Tooltip>\n          <Tooltip title=\"Stop\">\n            <div>\n              <IconButton color=\"inherit\"\n                disabled={ !enableStop }\n                onClick={ stopChannel }>\n                <StopIcon />\n              </IconButton>\n            </div>\n          </Tooltip>\n        </div>\n        <div className={ classes.headergroup }>\n          <Tooltip title=\"Zoom in\">\n            <IconButton color=\"inherit\"\n              onClick={ zoomIn }>\n              <ZoomInIcon />\n            </IconButton>\n          </Tooltip>\n          <Tooltip title=\"Zoom out\">\n            <IconButton color=\"inherit\"\n              onClick={ zoomOut }>\n              <ZoomOutIcon />\n            </IconButton>\n          </Tooltip>\n          <Tooltip title=\"Copy selected part\">\n            <div>\n              <IconButton disabled={ !entitySelected }\n                color=\"inherit\"\n                onClick={ copyParts }>\n                <ContentCopy />\n              </IconButton>\n            </div>\n          </Tooltip>\n          <Tooltip title=\"Paste part\">\n            <div>\n              <IconButton disabled={ !hasPartsToCopy }\n                color=\"inherit\"\n                onClick={ pasteParts }>\n                <ContentPaste />\n              </IconButton>\n            </div>\n          </Tooltip>\n          <Tooltip title=\"Delete selected\">\n            <div>\n              <IconButton disabled={ !entitySelected }\n                color=\"inherit\"\n                onClick={ deleteSelectedEntities }>\n                <DeleteIcon />\n              </IconButton>\n            </div>\n          </Tooltip>\n        </div>\n        <div className={ classes.headergroup }>\n          <Tooltip title=\"Update firmware\">\n            <IconButton color=\"secondary\"\n              onClick={ updateFirmware }>\n              <Autorenew />\n            </IconButton>\n          </Tooltip>\n\n        </div>\n\n      </div>\n    );\n  }\n}\n\nHeader.propTypes = {\n  classes: PropTypes.object.isRequired,\n  channelIds: PropTypes.array,\n  createImageChannel: PropTypes.func.isRequired,\n  saveShow: PropTypes.func.isRequired,\n  enablePlay: PropTypes.bool.isRequired,\n  playChannelAndImage: PropTypes.func.isRequired,\n  enableStop: PropTypes.bool.isRequired,\n  stopChannel: PropTypes.func.isRequired,\n  playChannelAndImageAction: PropTypes.func,\n  stopChannelAction: PropTypes.func,\n  zoomIn: PropTypes.func.isRequired,\n  zoomOut: PropTypes.func.isRequired,\n  entitySelected: PropTypes.bool,\n  deleteSelectedEntities: PropTypes.func.isRequired,\n  loadShowFromFile: PropTypes.func.isRequired,\n  setChannelInactive: PropTypes.func.isRequired,\n  setChannelActive: PropTypes.func.isRequired,\n  loadAudioFromFile: PropTypes.func.isRequired,\n  copyParts: PropTypes.func.isRequired,\n  pasteParts: PropTypes.func.isRequired,\n  hasPartsToCopy: PropTypes.bool,\n  updateFirmware: PropTypes.func.isRequired,\n};\n\nexport default withStyles(styles, {\n  withTheme: true\n})(Header);\n\n// export const HeaderWithTheme = withTheme(Header);","import {\n  CLEAR_MARKERS, SET_OR_REPLACE_MARKER, DELETE_MARKER, UPDATE_MARKER,\n} from \"./types\";\nimport { markerExists, getAllMarkers } from \"../reducers/markerReducer\";\n\n// first id will be 1 to avoid falsy ids\nlet lastMarkerIdCount = 0;\n\n// should only be used with care (e.g. in tests)\nexport function _setInitialMarkerIdCount(newId) {\n  lastMarkerIdCount = newId;\n}\n\nfunction generateId() {\n  // simple generator :-)\n  // other options: cuid or uuid\n  lastMarkerIdCount++;\n  return \"marker-\" + lastMarkerIdCount.toString();\n}\n\nfunction isValidMarkerType(type) {\n  return [\"insert\", \"selected\", \"timeScale\", \"insertTimeScale\"]\n    .includes(type);\n}\n\nexport const clearMarkers = () => ({\n  type: CLEAR_MARKERS,\n});\n\nexport function clearMarkersOfType(type) {\n  return (dispatch, getState) => {\n    if (isValidMarkerType(type)) {\n      Object.values(getAllMarkers(getState())).forEach((marker) => {\n        if (marker.type === type) {\n          dispatch(_deleteMarker(marker.markerId));\n        }\n      });\n    } else {\n      console.error(\"cannot clear markers of unknown type:\", type);\n    }\n  };\n}\n\nconst _setOrReplaceMarker = (markerInfo) => ({\n  type: SET_OR_REPLACE_MARKER,\n  payload: markerInfo\n});\n\nexport function setOrReplaceMarker(markerInfo) {\n  return (dispatch, getState) => {\n    // required fields\n    if (typeof markerInfo.pos == \"number\" &&\n      isValidMarkerType(markerInfo.type)) {\n      if (!markerInfo.markerId) {\n        markerInfo.markerId = generateId();\n      }\n      dispatch(_setOrReplaceMarker({\n        ...markerInfo\n      }));\n      return markerInfo.markerId;\n    }\n    console.error(\"cannot set or replace incomplete marker:\", markerInfo);\n    return null;\n  };\n}\n\nexport function setOrReplaceInsertMarker(pos) {\n  return (dispatch, getState) => {\n    dispatch(setOrReplaceMarker({\n      markerId: \"insertMarker\", // just one allowed\n      pos,\n      type: \"insert\"\n    }));\n  };\n}\n\nconst _deleteMarker = (markerId) => ({\n  type: DELETE_MARKER,\n  payload: markerId\n});\n\nexport function deleteMarker(markerId) {\n  return (dispatch, getState) => {\n    if (markerExists(getState(), markerId)) {\n      dispatch(_deleteMarker(markerId));\n    }\n  };\n}\n\nconst _updateMarker = (markerInfo) => ({\n  type: UPDATE_MARKER,\n  payload: markerInfo\n});\n\nexport const updateMarker = (markerInfo) => {\n  return (dispatch, getState) => {\n    // ensure we have what we need\n    // so reducers do not need to check assumptions\n    // update marker position either by incr or pos\n    // or update type\n    if (markerInfo.markerId) {\n      if (markerExists(getState(), markerInfo.markerId) && (\n        markerInfo.incr ||\n        typeof markerInfo.pos == \"number\" ||\n        markerInfo.type)) {\n        dispatch(_updateMarker(markerInfo));\n      }\n    } else {\n      console.error(\"marker does not have enough information to be updated:\", markerInfo);\n    }\n  };\n};\n\n////////////////////////////////////\n// actions in relation with parts //\n////////////////////////////////////\n\n// helpers to generate marker info from part\nfunction _getMarkerId(partId, type) {\n  return `${partId}--${type}`;\n}\n\nfunction _getPartLeftMarkerId(partId) {\n  return _getMarkerId(partId, \"left\");\n}\n\nfunction _getSelectedLeftMarker(partInfo) {\n  return {\n    markerId: _getPartLeftMarkerId(partInfo.partId),\n    pos: partInfo.offset,\n    type: \"selected\",\n    channelId: partInfo.channelId,\n    partId: partInfo.partId\n  };\n}\n\nfunction _getPartRightMarkerId(partId) {\n  return _getMarkerId(partId, \"right\");\n}\n\nfunction _getSelectedRightMarker(partInfo) {\n  return {\n    markerId: _getPartRightMarkerId(partInfo.partId),\n    pos: partInfo.offset + partInfo.duration,\n    type: \"selected\",\n    channelId: partInfo.channelId,\n    partId: partInfo.partId\n  };\n}\n\n// actions\n\nexport const addPartSelectionMarkers = (partInfo) => {\n  return (dispatch, getState) => {\n    const leftMarker = _getSelectedLeftMarker(partInfo);\n    dispatch(setOrReplaceMarker(leftMarker));\n    const rightMarker = _getSelectedRightMarker(partInfo);\n    dispatch(setOrReplaceMarker(rightMarker));\n  };\n};\n\nexport const deletePartSelectionMarkers = (partId) => {\n  return (dispatch, getState) => {\n    const leftMarkerId = _getPartLeftMarkerId(partId);\n    dispatch(deleteMarker(leftMarkerId));\n    const rightMarkerId = _getPartRightMarkerId(partId);\n    dispatch(deleteMarker(rightMarkerId));\n  };\n};\n\nexport const syncPartMarkers = (part) => {\n  return (dispatch, getState) => {\n    // will only update, when markers exist\n    const leftMarkerId = _getPartLeftMarkerId(part.partId);\n    dispatch(updateMarker({\n      pos: part.offset,\n      markerId: leftMarkerId\n    }));\n    const rightMarkerId = _getPartRightMarkerId(part.partId);\n    dispatch(updateMarker({\n      pos: part.offset + part.duration,\n      markerId: rightMarkerId\n    }));\n  };\n};\n","import {\r\n  ADD_IMAGE, CLEAR_IMAGELIST, REMOVE_IMAGE\r\n} from \"./types\";\r\nimport { getImageList, imageExists } from \"../reducers/imageListReducer\";\r\n\r\nconst _addImage = (imageInfo) => ({\r\n  type: ADD_IMAGE,\r\n  payload: imageInfo\r\n});\r\n\r\nexport function addImage(imageInfo) {\r\n  return (dispatch, getState) => {\r\n    // required fields\r\n    if ((imageInfo.filename || imageInfo.imageId) &&\r\n      imageInfo.src && imageInfo.width && imageInfo.height) {\r\n      // add imageId based on filename\r\n      const imageId = imageInfo.imageId || imageInfo.filename;\r\n      // only insert once\r\n      if (!imageExists(getState(), imageId)) {\r\n        dispatch(_addImage({\r\n          ...imageInfo,\r\n          imageId\r\n        }));\r\n        return imageId;\r\n      }\r\n    }\r\n    return null;\r\n  };\r\n};\r\n\r\nexport const clearImageList = () => ({\r\n  type: CLEAR_IMAGELIST\r\n});\r\n\r\nconst _removeImage = (imageId) => ({\r\n  type: REMOVE_IMAGE,\r\n  payload: imageId\r\n});\r\n\r\nexport function removeImage(imageId) {\r\n  return (dispatch, getState) => {\r\n    if (imageExists(getState(), imageId)) {\r\n      dispatch(_removeImage(imageId));\r\n    }\r\n  };\r\n};\r\n\r\n/**************************************/\r\n/******* LOAD / 'STORE ACTIONS ********/\r\n/**************************************/\r\n\r\nexport function loadImage(imageInfo) {\r\n  // base64 encoded images\r\n  if (imageInfo.src.startsWith(\"data:image\")) {\r\n    // we assume everything is in the record\r\n    return Promise.resolve(imageInfo);\r\n  }\r\n  // no longer read file from server\r\n}\r\n\r\nexport function saveImageToStorage(image) {\r\n  const key = \"image_\" + image.imageId;\r\n  const imageStr = JSON.stringify(image);\r\n  localStorage.setItem(key, imageStr);\r\n}\r\n\r\nexport function saveImagesToStorage(image) {\r\n  return (dispatch, getState) => {\r\n    const images = getImageList(getState());\r\n    images.forEach((img) => saveImageToStorage(img));\r\n  };\r\n}\r\n\r\n// load images from localstorage and add them to the store\r\nexport function loadImagesFromStorage() {\r\n  return (dispatch, getState) => {\r\n    return Object.keys(localStorage)\r\n      .filter((k) => k.startsWith(\"image_\"))\r\n      .reduce((res, key) => {\r\n        const img = JSON.parse(localStorage.getItem(key));\r\n        res.push(img);\r\n        return res;\r\n      }, [])\r\n      .forEach((img) => dispatch(addImage(img)));\r\n  };\r\n}\r\n\r\nexport function clearImagesfromStorage() {\r\n  return (dispatch, getState) => {\r\n    return Object.keys(localStorage)\r\n      .filter((k) => k.startsWith(\"image_\"))\r\n      .forEach((img) => localStorage.removeItem(img));\r\n  };\r\n}","\nimport { normalize } from \"normalizr\";\nimport {\n  CLEAR_PARTS, ADD_PART, DELETE_PART, RESIZE_PART, MOVE_PART, MOVE_PARTS,\n} from \"./types\";\nimport { getChannelId, partSchema, getPart, getPartIdsInInterval } from \"../reducers/partReducer\";\nimport { syncPartMarkers, deletePartSelectionMarkers } from \"./markerActions\";\n\nimport { toggleEntitySelection, selectEntity } from \"./entityActions\";\nimport { isEntitySelected, getSelectedEntityIdsOfType } from \"../reducers/entityReducer\";\nimport { getAllMarkerPosOfType } from \"../reducers/markerReducer\";\nimport { getChannelSnapDist, getChannelMinPartDuration } from \"../reducers/channelReducer\";\nimport { getSnapToMarkers } from \"../reducers/viewReducer\";\n\n// first id will be 1 to avoid falsy ids\nlet lastPartIdCount = 0;\n\n// should only be used with care (e.g. in tests)\nexport function _setInitialPartIdCount(newId) {\n  lastPartIdCount = newId;\n}\n\nfunction generateId() {\n  // simple generator :-)\n  // other options: cuid or uuid\n  lastPartIdCount++;\n  return \"part-\" + lastPartIdCount.toString();\n}\n\nconst _addPart = (partInfo) => ({\n  type: ADD_PART,\n  // normalize for easy usage in partReducer\n  // also add channelId for channelReducer\n  payload: {\n    ...normalize(partInfo, partSchema),\n  }\n});\n\n// create part id and add the part to the parts entities and channel\n// and conditionally selects new part\n// returns the new part id \nexport const createPart = (partInfo, selectNewPart = true) => {\n  return (dispatch, getState) => {\n    // ensure we have what we need\n    // so reducers do not need to check assumptions\n    if (partInfo.imageId && partInfo.channelId != null\n      && partInfo.offset != null && partInfo.duration != null) {\n\n      const partId = generateId();\n      // add part with new part id\n      dispatch(_addPart({\n        ...partInfo,\n        partId,\n      }));\n      if (selectNewPart) {\n        dispatch(toggleEntitySelection(partId));\n      }\n      return partId;\n    }\n    console.error(\"cannot add incomplete part:\", partInfo);\n    return null;\n  };\n};\n\n\n\nconst _deletePart = (partIdAndChannelId) => ({\n  type: DELETE_PART,\n  // no normalization should not be required since we can achieve this with partId and channelId alone\n  payload: partIdAndChannelId,\n});\n\nexport const deletePart = (partId) => {\n  return (dispatch, getState) => {\n    // ensure we have what we need\n    // so reducers do not need to check assumptions\n    const channelId = getChannelId(getState(), partId);\n\n    if (partId && channelId != null) {\n      dispatch(_deletePart({\n        partId,\n        channelId\n      }));\n      // in case it is selected:\n      dispatch(deletePartSelectionMarkers(partId));\n    } else {\n      console.error(\"cannot remove non-existing part:\", partId);\n    }\n  };\n};\n\nexport const clearParts = () => ({\n  type: CLEAR_PARTS\n});\n\nconst _movePart = (moveInfo, snapPositions, snapDist) => ({\n  type: MOVE_PART,\n  payload: {\n    ...moveInfo,\n    snapPositions,\n    snapDist,\n  }\n});\n\n// move part with snapping to markers\nexport const movePart = (moveInfo) => {\n  return (dispatch, getState) => {\n\n    // ensure we have what we need\n    // so reducers do not need to check assumptions\n    if (moveInfo.partId) {\n      // if incr is 0 no need to move\n      if (moveInfo.incr) {\n\n        let markerPositions = [];\n        let snapDist = null;\n        const withSnap = getSnapToMarkers(getState());\n        if (withSnap) {\n          // all markers are snap positions for start / end of part\n          // TODO: cache markers for one move operation\n          markerPositions = getAllMarkerPosOfType(getState(), \"timeScale\");\n          const channelId = getChannelId(getState(), moveInfo.partId);\n          snapDist = getChannelSnapDist(getState(), channelId);\n        }\n        dispatch(_movePart(moveInfo, markerPositions, snapDist));\n        // update markers based on actual move\n        dispatch(syncPartDeps(moveInfo.partId));\n      }\n    } else {\n      console.error(\"part does not have enough information to be moved:\", moveInfo);\n    }\n  };\n};\n\nconst _moveParts = (partIds, incr, snapPositions, snapDist) => ({\n  type: MOVE_PARTS,\n  payload: {\n    partIds,\n    incr,\n    snapPositions,\n    snapDist,\n  }\n});\n\n// move selected parts and snap\nexport const moveSelectedParts = (moveInfo) => {\n  return (dispatch, getState) => {\n    if (!isEntitySelected(getState(), moveInfo.partId)) {\n      // if part was not selected then exclusively select it for move\n      dispatch(toggleEntitySelection(moveInfo.partId));\n    }\n\n    if (moveInfo.incr) {\n      const partIdsToMove = getSelectedEntityIdsOfType(getState(), \"part\");\n\n      let markerPositions = [];\n      let snapDist = null;\n      const withSnap = getSnapToMarkers(getState());\n      if (withSnap) {\n        // all markers are snap positions for start / end of part\n        // TODO: cache markers for one move operation\n        markerPositions = getAllMarkerPosOfType(getState(), \"timeScale\");\n        const channelId = getChannelId(getState(), moveInfo.partId);\n        snapDist = getChannelSnapDist(getState(), channelId);\n      }\n      dispatch(_moveParts(partIdsToMove, moveInfo.incr, markerPositions, snapDist));\n      partIdsToMove.forEach((partId) =>\n        dispatch(syncPartDeps(partId)));\n    }\n  };\n};\n\nconst _resizePart = (resizeInfo, snapPositions, snapDist, minDuration) => ({\n  type: RESIZE_PART,\n  payload: {\n    ...resizeInfo,\n    snapPositions,\n    snapDist,\n    minDuration,\n  }\n});\n\nexport const resizePart = (resizeInfo) => {\n  return (dispatch, getState) => {\n\n    // ensure we have what we need\n    // so reducers do not need to check assumptions\n    if (resizeInfo.partId && resizeInfo.markerId) {\n      // exclusively select this part\n      dispatch(toggleEntitySelection(resizeInfo.partId));\n      // if incr is 0 no need to resize\n      if (resizeInfo.incr) {\n        const channelId = getChannelId(getState(), resizeInfo.partId);\n        resizeInfo.bound = resizeInfo.markerId.includes(\"right\") ? \"right\" : \"left\";\n\n        let markerPositions = [];\n        let snapDist = null;\n        const minDuration = getChannelMinPartDuration(getState(), channelId);\n        const withSnap = getSnapToMarkers(getState());\n        if (withSnap) {\n          // all markers are snap positions for start / end of part\n          // TODO: cache markers for one move operation\n          markerPositions = getAllMarkerPosOfType(getState(), \"timeScale\");\n          snapDist = getChannelSnapDist(getState(), channelId);\n        }\n        dispatch(_resizePart(resizeInfo, markerPositions, snapDist, minDuration));\n        // update markers based on actual resize\n        dispatch(syncPartDeps(resizeInfo.partId));\n      }\n    } else {\n      console.error(\"part does not have enough information to be resized:\",\n        resizeInfo);\n    }\n  };\n};\n\nexport const syncPartDeps = (partId) => {\n  return (dispatch, getState) => {\n    const part = getPart(getState(), partId);\n    if (part) {\n      // currently only part markers need to be synced\n      dispatch(syncPartMarkers(part));\n    } else {\n      console.error(\"part to sync deps for does not exist:\", partId);\n    }\n  };\n};\n\n\nexport const selectInInterval = ((selectedChannelId, from, to) => {\n  return (dispatch, getState) => {\n    const partIds = getPartIdsInInterval(getState(), selectedChannelId, from, to);\n    partIds.forEach((pId) => dispatch(selectEntity(pId)));\n  };\n});\n","import {\n  SELECT_ENTITY, DESELECT_ENTITY, CLEAR_ENTITY_SELECTION, COPY_ENTITIES,\n} from \"./types\";\nimport { entityExists, isEntitySingleSelected, isEntitySelected, getSelectedEntityType, getEntityType, isEntitySelectable, getSelectedEntityIds, getSelectedEntityIdsOfType, getEntitiesIdsToCopy } from \"../reducers/entityReducer\";\nimport { clearMarkersOfType, addPartSelectionMarkers, deletePartSelectionMarkers } from \"./markerActions\";\nimport { partExists, getPart } from \"../reducers/partReducer\";\nimport { removeImage } from \"./imageListActions\";\nimport { deletePart, createPart } from \"./partActions\";\nimport { getSelectedImageChannelId } from \"../reducers/viewReducer\";\n\nconst _selectEntity = (entityId) => ({\n  type: SELECT_ENTITY,\n  payload: entityId\n});\n\nexport function selectEntity(entityId) {\n  return (dispatch, getState) => {\n    // ensure that entity exists and is selectable\n    if (entityExists(getState(), entityId) && isEntitySelectable(getState(), entityId)) {\n      if (!isEntitySelected(getState(), entityId)) {\n        dispatch(_selectEntity(entityId));\n        // for part: also add markers\n        if (partExists(getState(), entityId)) {\n          const part = getPart(getState(), entityId);\n          dispatch(addPartSelectionMarkers(part));\n          // channel is directly selected thru mouse handler\n        }\n      }\n    } else {\n      console.error(\"entity to select does not exist or is not selectable:\", entityId);\n    }\n  };\n};\n\nexport const _deselectEntity = (entityId) => ({\n  type: DESELECT_ENTITY,\n  payload: entityId\n});\n\nexport function deselectEntity(entityId) {\n  return (dispatch, getState) => {\n    // ensure that entity exists and is selectable\n    if (entityExists(getState(), entityId) && isEntitySelectable(getState(), entityId)) {\n      dispatch(_deselectEntity(entityId));\n      // for part: also delete markers\n      if (partExists(getState(), entityId)) {\n        dispatch(deletePartSelectionMarkers(entityId));\n      }\n    } else {\n      console.error(\"entity to deselect does not exist or is not selectable:\", entityId);\n    }\n  };\n};\n\nexport const _clearEntitySelection = () => ({\n  type: CLEAR_ENTITY_SELECTION\n});\n\nexport function clearEntitySelection() {\n  return (dispatch, getState) => {\n    dispatch(_clearEntitySelection());\n    dispatch(clearMarkersOfType(\"selected\")); // just do it in any case\n    dispatch(clearMarkersOfType(\"insert\"));\n  };\n};\n\n// TODO: think about entity reducer actions instead of part/image actions\nexport function deleteSelectedEntities() {\n  return (dispatch, getState) => {\n    // assuming all entities are of the same type\n    const entityType = getSelectedEntityType(getState());\n\n    getSelectedEntityIds(getState()).forEach((entityId) => {\n      if (entityType === \"part\") {\n        dispatch(deletePart(entityId));\n      } else if (entityType === \"image\") {\n        dispatch(removeImage(entityId));\n      }\n    });\n  };\n};\n\nexport const _copyEntities = (entityIds) => ({\n  type: COPY_ENTITIES,\n  payload: entityIds\n});\n\n// we only copy parts for now, no other entity types\nexport function copyParts() {\n  return (dispatch, getState) => {\n    const parts = getSelectedEntityIdsOfType(getState(), \"part\");\n    if (parts.length > 0) {\n      dispatch(_copyEntities(parts));\n    }\n  };\n};\n\nexport const pasteParts = () => {\n  return (dispatch, getState) => {\n    // expect only parts here\n    getEntitiesIdsToCopy(getState()).forEach((partId) => {\n      const originalPart = getPart(getState(), partId);\n      const selectedImageChannelId = getSelectedImageChannelId(getState());\n\n      if (selectedImageChannelId) {\n        const partToPaste = {\n          ...originalPart,\n          channelId: selectedImageChannelId,\n        };\n        dispatch(createPart(partToPaste));\n      }\n    });\n  };\n};\n\n/*********************************/\n/* Different selection functions */\n/*********************************/\n\n// only one enity can be selected (for single click)\nexport function toggleEntitySelection(entityId) {\n  return (dispatch, getState) => {\n\n    // ensure we have what we need\n    // so reducers do not need to check assumptions\n    if (entityId && entityExists(getState(), entityId)) {\n\n      const entitySingleSelected = isEntitySingleSelected(getState(), entityId);\n      // simpler to deselect everything instead of deselection prev selection\n      dispatch(clearEntitySelection());\n\n      if (!entitySingleSelected) {\n        dispatch(selectEntity(entityId));\n      }\n    }\n  };\n};\n\n// many entities can be selected (for ctrl-click)\nexport function toggleMultiEntitySelection(entityId) {\n  return (dispatch, getState) => {\n\n    // check condition\n    if (entityId && entityExists(getState(), entityId)) {\n\n      // if other entity type was selected: clean selection first\n      if (getEntityType(getState(), entityId) !== getSelectedEntityType(getState())) {\n        dispatch(clearEntitySelection());\n        dispatch(selectEntity(entityId));\n      } else if (isEntitySelected(getState(), entityId)) {\n        dispatch(deselectEntity(entityId));\n      } else {\n        dispatch(selectEntity(entityId));\n      }\n    }\n  };\n};\n\n// adds entity selection if not yet selected (for mouse-down-click)\nexport function toggleInitialEntitySelection(entityId) {\n  return (dispatch, getState) => {\n\n    // check condition\n    if (entityId && entityExists(getState(), entityId)) {\n      if (!isEntitySelected(getState(), entityId)) {\n        dispatch(clearEntitySelection());\n        dispatch(selectEntity(entityId));\n      }\n    }\n  };\n};\n","// sampleRate: samples in image or sound per second\r\n// resolution: pixels on screen per second (was: pixels per sample)\r\n\r\nexport function samplesToSeconds(samples, sampleRate) {\r\n  return samples / sampleRate;\r\n}\r\n\r\nexport function secondsToSamples(seconds, sampleRate, toCeil = true) {\r\n  return toCeil ?\r\n    Math.ceil(seconds * sampleRate) : Math.floor(seconds * sampleRate);\r\n}\r\n\r\nexport function samplesToPixels(samples, resolution, sampleRate) {\r\n  return Math.floor((samples * resolution) / sampleRate);\r\n}\r\n\r\nexport function pixelsToSamples(pixels, resolution, sampleRate) {\r\n  return Math.floor((pixels * sampleRate) / resolution);\r\n}\r\n\r\nexport function pixelsToSeconds(pixels, resolution) {\r\n  return pixels / resolution;\r\n}\r\n\r\nexport function secondsToPixels(seconds, resolution) {\r\n  return Math.ceil(seconds * resolution);\r\n}\r\n\r\nexport function secondsToRad(seconds, rotationSpeed) {\r\n  // do not exceed full circle\r\n  const factor = (seconds * rotationSpeed) % 1;\r\n  return 2 * Math.PI * factor;\r\n}\r\n\r\nexport function samplesToRad(samples, sampleRate, rotationSpeed) {\r\n  // do not exceed full circle\r\n  const factor = (samples * rotationSpeed / sampleRate) % 1;\r\n  return 2 * Math.PI * factor;\r\n}","import {\n  SELECT_RANGE, DESELECT_RANGE, SET_RESOLUTION, CLEAR_VIEW,\n  SELECT_IMAGE_CHANNEL, ADD_TO_UPLOAD_LOG, CLEAR_UPLOAD_LOG, SET_MESSAGE,\n  CLEAR_MESSAGE, INIT_LOAD_PROGRESS, SET_LOAD_PROGRESS, INCR_LOAD_PROGRESS,\n  TOGGLE_SNAP_TO_MARKER\n} from \"./types\";\nimport { getAllChannelIds, getChannelSampleRate } from \"../reducers/channelReducer\";\nimport { updateChannel } from \"./channelActions\";\nimport { pixelsToSeconds } from \"../utils/conversions\";\n\nexport const clearView = () => ({\n  type: CLEAR_VIEW\n});\n\nexport const selectRange = (selectInfo) => ({\n  type: SELECT_RANGE,\n  payload: selectInfo\n});\n\nexport const deselectRange = () => ({\n  type: DESELECT_RANGE\n});\n\nconst _setResolution = (resolution) => ({\n  type: SET_RESOLUTION,\n  payload: resolution\n});\n\nexport const setResolution = (resolution) => {\n  return (dispatch, getState) => {\n    dispatch(_setResolution(resolution));\n    getAllChannelIds(getState()).forEach((channelId) =>\n      dispatch(updateChannel({\n        channelId,\n        minPartDuration: pixelsToSeconds(5, resolution,\n          getChannelSampleRate(getState(), channelId)),\n        snapDist: pixelsToSeconds(10, resolution,\n          getChannelSampleRate(getState(), channelId)),\n      })));\n  };\n};\n\nexport const selectImageChannel = (channelId) => ({\n  type: SELECT_IMAGE_CHANNEL,\n  payload: channelId\n});\n\nexport const addToUploadLog = (text) => ({\n  type: ADD_TO_UPLOAD_LOG,\n  payload: text\n});\n\nexport const clearUploadLog = () => ({\n  type: CLEAR_UPLOAD_LOG\n});\n\nexport const setMessage = (text) => ({\n  type: SET_MESSAGE,\n  payload: text\n});\n\nexport const clearMessage = () => ({\n  type: CLEAR_MESSAGE\n});\n\nexport const initLoadProgress = (base) => ({\n  type: INIT_LOAD_PROGRESS,\n  payload: base,\n});\n\nexport const setLoadProgress = (progress) => ({\n  type: SET_LOAD_PROGRESS,\n  payload: progress,\n});\n\nexport const incrLoadProgress = (incr) => ({\n  type: INCR_LOAD_PROGRESS,\n  payload: incr,\n});\n\nexport const toggleSnapToMarkers = () => ({\n  type: TOGGLE_SNAP_TO_MARKER,\n});","import { useReducer, useState } from 'react';\nimport { useDispatch } from 'react-redux'\nimport { toggleEntitySelection, toggleMultiEntitySelection } from '../actions/entityActions';\nimport { addImage } from '../actions/imageListActions';\nimport { setMessage } from '../actions/viewActions';\nimport { samplesToSeconds } from '../utils/conversions';\n\n\nconst initialState = { count: 0 };\n\nfunction counterReducer(state, action) {\n  switch (action.type) {\n    case 'reset':\n      return { count: 0 };\n    case 'increment':\n      return { count: state.count + 1 };\n    case 'decrement':\n      return { count: state.count - 1 };\n    default:\n      throw new Error();\n  }\n}\n\n// handles all mouse events for the dragg action in the ImageList\n\nexport function useImageDnDMouseEvent(sampleRate) {\n\n  const [dragging, setDragging] = useState(false);\n  const [draggingCounterState, dispatchDraggingCounter] =\n    useReducer(counterReducer, initialState);\n  const dispatch = useDispatch();\n\n  // if TimeToPixels HOC wraps the Channel then pos is in secs\n  function handleMouseEvent(eventName, e) {\n    //console.log(evInfo, eventName);\n    e.preventDefault();\n    e.stopPropagation();\n\n    switch (eventName) {\n\n      case \"mouseUp\":\n        handleSelectImage(e);\n        break;\n\n      case \"dragEnter\":\n        startDrag();\n        break;\n\n      case \"dragLeave\":\n        endDrag();\n        break;\n\n      case \"drop\":\n        dropImage(e);\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  function handleSelectImage(e) {\n    let el = e.target;\n    const imageId = el.getAttribute(\"data-imageid\");\n    if (e.ctrlKey) {\n      dispatch(toggleMultiEntitySelection(imageId));\n    } else {\n      dispatch(toggleEntitySelection(imageId));\n    }\n  }\n\n  function startDrag() {\n    dispatchDraggingCounter({ type: 'increment' });\n    setDragging(true);\n  }\n\n  function endDrag() {\n    dispatchDraggingCounter({ type: 'decrement' });\n    if (draggingCounterState.count <= 0) {\n      setDragging(false);\n      dispatchDraggingCounter({ type: 'reset' });\n    }\n  }\n\n  function dropImage(e) {\n    setDragging(false);\n    dispatchDraggingCounter({ type: 'reset' });\n\n    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {\n      const fileList = e.dataTransfer.files;\n      for (var i = 0; i < fileList.length; i++) {\n        loadImageAndAddToStore(fileList[i]);\n      }\n    }\n  }\n\n  function loadImageAndAddToStore(file) {\n    var reader = new FileReader();\n    var img = new Image();\n\n    reader.onload = function (e) {\n      img.src = reader.result;\n    };\n    img.onload = function () {\n\n      if (img.height !== 30) {\n        dispatch(setMessage({\n          type: \"error\",\n          title: \"Wrong image size\",\n          text: `The dragged image ${file.name} has a height of ${img.height}. However, you can only add images with a height of 30 pixels.`\n        }));\n      } else {\n        const newImage = {\n          width: img.width,\n          height: img.height,\n          src: reader.result,\n          filename: file.name,\n          sampleRate,\n          duration: samplesToSeconds(img.width, sampleRate)\n        };\n        dispatch(addImage(newImage));\n      }\n    };\n    reader.readAsDataURL(file);\n  }\n\n  // return the mouse event handling function to be used in the component\n  return [\n    (eventName, evInfo) => handleMouseEvent(eventName, evInfo),\n    dragging\n  ]\n}","import React, { useEffect } from \"react\";\nimport PropTypes from \"prop-types\";\nimport styled from \"styled-components\";\n\nimport { useImageDnDMouseEvent } from \"../hooks/useImageDnDMouseEvent\";\n\nconst ImageListWrapper = styled.div`\n\tdisplay: flex;\n\tflex-direction: row;\n\talign-content: flex-start;\n\twidth: calc(100% - 16px);\n\theight: 100%;\n\toverflow: auto;\n\tflex-wrap: wrap;\n\tmargin: 20px 8px;\n\tbackground:  ${props => props.backgroundColor};\n\tborder: 3px dashed ${props => props.borderColor}; \n\tborder-radius: 10px;\n`;\n\nconst ImageInList = styled.img`\n\tmargin: 3px;\n\tmax-height: 30px;\n\tborder: 2px solid ${props => props.borderColor};\n`;\n\nconst DropHereLabel = styled.label`\n\twidth: 100%;\n\tpadding-top: 80px;\n\ttext-align: center;\n\tjustify-content: center;\n\tfont-size: 14pt;\n\tfont-weight: 600;\n\tcolor: darkgrey;\n`;\n\nfunction ImageList(props) {\n\n  const { images, sampleRate } = props;\n\n  useEffect(() => {\n    props.loadImagesFromStorage()\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const [handleMouseEvent, dragging] = useImageDnDMouseEvent(sampleRate);\n\n\n\n  const imagesComponent = images.map((img) => (\n    <ImageInList id={img.imageId}\n      key={img.imageId}\n      src={img.src}\n      data-imageid={img.imageId}\n      borderColor={props.isEntitySelected(img.imageId) ? \"red\" : \"transparent\"}\n      draggable\n      onDragStart={(e) => {\n        e.dataTransfer.setData(\"imageid\", img.imageId);\n        e.dataTransfer.setData(\"duration\", img.duration);\n      }} />\n  ));\n\n  const dropHereLabel = images.length > 0 ? null :\n    <DropHereLabel center> Drop your images here </DropHereLabel>;\n\n  return (\n    <ImageListWrapper borderColor={images.length > 0 ? \"tranparent\" : \"darkgrey\"}\n      onMouseUp={(e) => handleMouseEvent(\"mouseUp\", e)}\n      onDragEnter={(e) => handleMouseEvent(\"dragEnter\", e)}\n      onDragEnd={(e) => handleMouseEvent(\"dragEnd\", e)}\n      onDragExit={(e) => handleMouseEvent(\"dragExit\", e)}\n      onDragLeave={(e) => handleMouseEvent(\"dragLeave\", e)}\n      onDragOver={(e) => handleMouseEvent(\"dragOver\", e)}\n      onDrop={(e) => handleMouseEvent(\"drop\", e)}\n      backgroundColor={dragging ? \"darkgrey\" : \"white\"}>\n      {dropHereLabel}\n      {imagesComponent}\n    </ImageListWrapper>\n  );\n}\n\n\nImageList.propTypes = {\n  images: PropTypes.array, // all images\n  loadImagesFromStorage: PropTypes.func.isRequired,\n  toggleEntitySelection: PropTypes.func.isRequired,\n  toggleMultiEntitySelection: PropTypes.func.isRequired,\n  isEntitySelected: PropTypes.func.isRequired,\n  sampleRate: PropTypes.number.isRequired,\n  addImage: PropTypes.func.isRequired,\n  setMessage: PropTypes.func.isRequired,\n};\n\nexport default ImageList;","import React, { Component } from \"react\";\nimport { connect } from \"react-redux\";\nimport PropTypes from \"prop-types\";\n\nimport ImageList from \"./ImageList\";\nimport { getImageList } from \"../reducers/imageListReducer\";\nimport { saveImageToStorage, addImage, loadImagesFromStorage } from \"../actions/imageListActions\";\nimport { setMessage } from \"../actions/viewActions\";\nimport { toggleEntitySelection, toggleMultiEntitySelection } from \"../actions/entityActions\";\nimport { isEntitySelected } from \"../reducers/entityReducer\";\n\nexport const defaultSampleRate = 100;\n\nclass ImageListContainer extends Component {\n\n  render() {\n    return (<ImageList\n      { ...this.props }\n      sampleRate={ defaultSampleRate }\n      selectImage={ this.props.toggleEntitySelection }\n      selectMultiImage={ this.props.toggleMultiEntitySelection }\n    />);\n  }\n}\n\nconst mapStateToProps = (state, props) => {\n  return {\n    images: getImageList(state),\n    isEntitySelected: (entityId) => isEntitySelected(state, entityId),\n  };\n};\n\nconst mapDispatchToProps = dispatch => ({\n  addImage: (image) => dispatch(addImage(image)),\n  setMessage: (text, type, title) => dispatch(setMessage({ text, type, title })),\n  toggleEntitySelection: (imageId) => dispatch(toggleEntitySelection(imageId)),\n  toggleMultiEntitySelection: (imageId) => dispatch(toggleMultiEntitySelection(imageId)),\n  saveImageToStorage: (imageFile, key) => dispatch(saveImageToStorage(imageFile, key)),\n  loadImagesFromStorage: () => dispatch(loadImagesFromStorage()),\n});\n\nImageListContainer.propTypes = {\n  images: PropTypes.array, // all images\n  addImage: PropTypes.func.isRequired,\n  setMessage: PropTypes.func.isRequired,\n  toggleEntitySelection: PropTypes.func.isRequired,\n  toggleMultiEntitySelection: PropTypes.func.isRequired,\n  loadImagesFromStorage: PropTypes.func.isRequired,\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(ImageListContainer);\n","\r\nimport { saveAs } from \"file-saver\";\r\n\r\nexport function downloadTextfile(filename, text) {\r\n  downloadFile(filename, \"data:application/json;charset=utf-8,\" + encodeURIComponent(text));\r\n}\r\n\r\nexport function downloadImagefile(filename, imageUrl) {\r\n  downloadFile(filename, imageUrl);\r\n}\r\n\r\nexport function downloadBinaryFile(filename, uint8array) {\r\n  // const binaryData0 = btoa(String.fromCharCode(...uint8array));\r\n  // const decoder = new TextDecoder(\"utf8\");\r\n  // const binaryData = btoa(decoder.decode(uint8array));\r\n  //var binaryData = btoa(Uint8ToString(uint8array));\r\n  // const fileData = \"data:application/octet-stream;base64,\" + binaryData;\r\n  // downloadFile(filename, fileData);\r\n  var blob = new Blob([uint8array], { type: \"data:application/octet-stream;base64\" });\r\n  saveAs(blob, filename);\r\n}\r\n\r\nexport function downloadFile(filename, src) {\r\n  const element = document.createElement(\"a\");\r\n  element.setAttribute(\"href\", src);\r\n  element.setAttribute(\"download\", filename);\r\n\r\n  element.style.display = \"none\";\r\n  document.body.appendChild(element);\r\n\r\n  element.click();\r\n\r\n  document.body.removeChild(element);\r\n}\r\n\r\nexport function readTextFile(file) {\r\n  return new Promise((resolve, reject) => {\r\n    var fr = new FileReader();\r\n    fr.onload = () => {\r\n      resolve(fr.result);\r\n    };\r\n    fr.readAsText(file);\r\n  });\r\n}\r\n\r\nexport function readAudioFile(file, audioContext) {\r\n  return new Promise((resolve, reject) => {\r\n    var fr = new FileReader();\r\n    fr.onload = () => {\r\n      audioContext.decodeAudioData(fr.result)\r\n        .then((decodedAudio) => resolve(decodedAudio));\r\n    };\r\n    fr.readAsArrayBuffer(file);\r\n  });\r\n}\r\n\r\n\r\nexport function getBase64Image(img) {\r\n  var canvas = document.createElement(\"canvas\");\r\n  canvas.width = img.width;\r\n  canvas.height = img.height;\r\n\r\n  var ctx = canvas.getContext(\"2d\");\r\n  ctx.drawImage(img, 0, 0);\r\n\r\n  var dataURL = canvas.toDataURL(\"image/png\");\r\n\r\n  return dataURL.replace(/^data:image\\/(png|jpg);base64,/, \"\");\r\n}","\nexport function encodeImage(a) {\n  return runtimeEncodeImage(a);\n  // return encodeImagePlain(a);\n}\n\nexport function runtimeEncodeImage(a) {\n\n  // console.log(\"Start encoding...\", a);\n\n  const buffer = new ArrayBuffer(3 + 4 * a.width * a.height); // max size when every pixel was different\n  const output = new Uint8Array(buffer);\n\n  let o = 0; // start index in output array\n  let cnt = 0; // number of pixel with same value\n  let prev = [-1, -1, -1]; // remember prev value\n\n  // output header: encoding-id(1), width, height (16bit)\n  output[o++] = 1;\n  output[o++] = a.height;\n  const widthUpper = Math.floor(a.width/256);\n  output[o++] = widthUpper;\n  output[o++] = a.width - (widthUpper * 256);\n\n  for (let col = 0; col < a.width; col++) {\n    // initialize prev value with first value of column\n    // console.log(\"col: \", col);\n\tconst idx = 4*col;\n    prev = [a.data[idx], a.data[idx+1], a.data[idx+2]];\n    cnt = 1; // runtime count\n    // console.log(\"first val: \", prev);\n\n    // start with second value of col\n    for (let row = 1; row < a.height; row++) {\n      // convert row-based to column-based, skipp transparency (4th bit)\n      // s: start index in input array\n      const s = 4 * (row * a.width + col);\n\n      //  value === prev value: no output, but increment count\n      if (prev[0] ===  a.data[s] &&\n        prev[1] ===  a.data[s+1] &&\n        prev[2] ===  a.data[s+2]) {\n        cnt++;\n      } else {\n        // new value: output prev value with count\n        output[o++] = prev[0];\n        output[o++] = prev[1];\n        output[o++] = prev[2];\n        output[o++] = cnt;\n        // console.log(`save val: ${prev}, ${cnt}`);\n\n        // remember current value as prev value\n        prev = [a.data[s], a.data[s+1], a.data[s+2]];\n        // console.log(\"new val: \", prev);\n        cnt = 1; // reset runtime count\n      }\n    }\n\n    // end of column: output last value with count\n    output[o++] = prev[0];\n    output[o++] = prev[1];\n    output[o++] = prev[2];\n    output[o++] = cnt;\n    // console.log(`save val: ${prev}, ${cnt}`);\n  }\n  console.log(`orig size: ${a.width}x${a.height}: ${3*a.width*a.height} bytes`);\n  console.log(`enc. size: ${o} bytes, reduction: ${100-Math.round(100*o/(3*a.width*a.height))}%`);\n  return output.subarray(0, o);\n}\n\nexport function runtimeDecodeImage(a) {\n\n  // console.log(\"Start decoding...\", a);\n  // input index\n  let i = 0;\n  // runtime count\n  let cnt = 0;\n\n  // read header\n  if (a[i++] !== 1) {\n    throw new Error(\"image not runtime encoded\");\n  }\n  const height = a[i++];\n  const widthUpper = a[i++];\n  const widthLower = a[i++];\n  const width = widthLower + widthUpper * 256;\n  // console.log(`${width}x${height}`);\n\n  const buffer = new ArrayBuffer(4 * width * height); \n  const output = new Uint8Array(buffer);\n\n  for (let col = 0; col < width; col++) {\n    for (let row = 0; row < height; row++) {\n      // output index \n      let o = 4 * (row * width + col);\n\n      output[o] = a[i];\n      output[o+1] = a[i+1];\n      output[o+2] = a[i+2];\n      output[o+3] = 0; // no transparency\n     //  console.log(`${col},${row}-${o}: out ${output.subarray(o, o+4)}`);\n      cnt++;\n\n      // use next input value\n      if (cnt === a[i+3]){\n        i+=4;\n        cnt = 0;\n      }\n    }\n  }\n  return output;\n}\n\nexport function encodeImagePlain(a) {\n  const buffer = new ArrayBuffer(3 + 3 * a.width * a.height);\n  const output = new Uint8Array(buffer);\n\n  // output header: encoding-id(1), width, height\n  output[0] = 0;\n  output[1] = a.height;\n  output[2] = a.width;\n\n  for (let col = 0; col < a.width; col++) {\n    for (let row = 0; row < a.height; row++) {\n      // convert row-based to column-based, skipp transparency (4th bit)\n      // s: start index in input array\n      // input has r-g-b-transp values\n      const s = 4 * (row * a.width + col);\n      // o: start index in output array\n      const o = 3 + 3 * (col * a.height + row);\n      output[o] = a.data[s];\n      output[o+1] = a.data[s+1];\n      output[o+2] = a.data[s+2];\n    }\n  }\n  return output;\n}\n\n// appy a gain (<.99) to canvas image data\nexport function applyGain(gain, data) {\n\n}\n\n","\nimport isElectron from \"is-electron\";\nimport LogScale from \"log-scale\";\nimport { LOAD_SHOW_STARTED, LOAD_SHOW_SUCCESS, LOAD_SHOW_FAILURE, LOAD_AUDIO_SUCCESS, LOAD_AUDIO_FAILURE, LOAD_AUDIO_STARTED } from \"./types\";\n\nimport { downloadTextfile, readTextFile, /* downloadImagefile, */ downloadBinaryFile, readAudioFile } from \"../utils/fileUtils\";\n\nimport { addChannel } from \"./channelActions\";\nimport { addImage, loadImage } from \"./imageListActions\";\nimport { addToUploadLog } from \"./viewActions\";\n\nimport { getMaxChannelDuration, getChannelGain, getChannelSampleRate, getChannelParts, getAllDenormalizedChannels } from \"../reducers/channelReducer\";\nimport { imageExists, getImageList } from \"../reducers/imageListReducer\";\n\nimport { secondsToSamples } from \"../utils/conversions\";\nimport { encodeImage } from \"../utils/imageUtils\";\nimport { getAllMarkersOfType } from \"../reducers/markerReducer\";\nimport { setOrReplaceMarker } from \"./markerActions\";\n\n\nconst logScale = new LogScale(0, 100);\n\n// load channels and images from show file\n\nconst loadShowStarted = startInfo => ({\n  type: LOAD_SHOW_STARTED,\n  payload: startInfo,\n});\n\nconst loadShowSuccess = channelInfo => ({\n  type: LOAD_SHOW_SUCCESS,\n  payload: channelInfo,\n});\n\nconst loadShowFailure = errorInfo => ({\n  type: LOAD_SHOW_FAILURE,\n  payload: errorInfo,\n});\n\nexport const loadShowFromFile = (showFile) => (dispatch, getState) => {\n  dispatch(loadShowStarted());\n  console.log(`Reading ${showFile.name}...`);\n\n  return readTextFile(showFile)\n    .then((data) => {\n      const dataObj = JSON.parse(data);\n      return dispatch(_uploadShow(dataObj));\n    })\n    .then(() => {\n      return dispatch(loadShowSuccess());\n    })\n    .catch((err) => {\n      console.error(err);\n      return dispatch(loadShowFailure({\n        err,\n      }));\n    });\n};\n\nconst _uploadShow = (showData) => (dispatch, getState) => {\n\n  console.log(showData);\n  // dispatch(clearView());\n  // dispatch(clearImageList());\n  // dispatch(clearChannels());\n\n  // load all non-existing images and save them to store\n  const imageListPromises = showData.images\n    .filter(imageData => !imageExists(getState(), imageData.imageId))\n    .map(imageData => loadImage(imageData)\n      .then((img) => {\n        console.log(`loading image ${img.imageId}`);\n        return dispatch(addImage(img));\n      }));\n\n  const markerPromises = showData.markers ? showData.markers\n    .map(marker => dispatch(setOrReplaceMarker(marker))) : [];\n\n  return Promise.all(imageListPromises)\n    .then(() => {\n      console.log(\"images loaded.\");\n      return Promise.all(markerPromises);\n    })\n    .then(() => {\n      console.log(\"markers loaded.\");\n\n      // load all channels\n      const channelPromises = showData.channels\n        .map((channelData) => {\n          if (channelData.type === \"image\") {\n            const channelId = dispatch(addChannel(channelData));\n            if (!channelId) {\n              console.log(\"Loading image channel failed. Skipped channel...\");\n            } else {\n              console.log(`${channelData.type} channel added.`);\n            }\n          } else {\n            console.log(`Loading channel with type ${channelData.type} is not supported. Skipped channel...`);\n          }\n          return Promise.resolve();\n        });\n\n      return Promise.all(channelPromises);\n    });\n};\n\nfunction removeObjectKeys(obj, keysToRemove) {\n  return JSON.parse(JSON.stringify(obj, (k, v) => keysToRemove.includes(k) ? undefined : v));\n}\n\nexport const saveShow = (() => (dispatch, getState) => {\n  const show = {\n    markers: getAllMarkersOfType(getState(), \"timeScale\"),\n    images: getImageList(getState()),\n    channels: removeObjectKeys(getAllDenormalizedChannels(getState()), [\"partId\", \"channelId\"])\n  };\n  downloadTextfile(\"show.json\", JSON.stringify(show));\n});\n\n// clear export image section (make black)\nexport const clearExportImage = numChannels => (dispatch, getState) => {\n  if (numChannels) {\n    const maxDuration = getMaxChannelDuration(getState());\n    const canvas = document.getElementById(\"imageExportCanvas\");\n    canvas.height = numChannels * 30;\n    canvas.width = secondsToSamples(maxDuration, 100); // TODO: actual sample rate\n\n    const cc = canvas.getContext(\"2d\");\n    cc.fillStyle = \"black\";\n    cc.fillRect(0, 0, canvas.width, canvas.height);\n  }\n};\n\n// draw a channel to the export at position idx\nexport const drawExportImage = (channelId, idx, applyLog) => (dispatch, getState) => {\n  const chGain = getChannelGain(getState(), channelId);\n  const sampleRate = getChannelSampleRate(getState(), channelId);\n  const parts = getChannelParts(getState(), channelId);\n\n  if (parts) {\n    const canvas = document.getElementById(\"imageExportCanvas\");\n    const cc = canvas.getContext(\"2d\");\n\n    parts.forEach((part) => {\n\n      const img = document.getElementById(part.imageId);\n      const offsetPx = part.offset ? secondsToSamples(part.offset, sampleRate) : 0;\n      const widthPx = part.duration ? secondsToSamples(part.duration, sampleRate) : 0;\n      cc.drawImage(img, 0, 0, img.width, 30, offsetPx, idx * 30, widthPx, 30);\n    });\n\n    // apply gain by adding a transparent black rectangle on top of the parts\n    if (chGain && chGain < 0.99) {\n      // use log gain because otherwise it fades to strongly\n      const gain = applyLog ? logScale.linearToLogarithmic(chGain) / 100 : chGain;\n\n      cc.fillStyle = \"black\";\n      cc.globalAlpha = 1.0 - gain;\n      cc.fillRect(0, idx * 30, canvas.width, 30);\n    }\n  }\n};\n\n// export one channel to canvas and save as binary\nexport const saveImageChannelAsBinary = channelId => (dispatch, getState) => {\n  dispatch(clearExportImage(1));\n  dispatch(drawExportImage(channelId, 0, true));\n  // binary download\n  const data = getChannelExportData();\n\n  // export/save binary encoded image for poi\n  downloadBinaryFile(`result-${channelId}.poi`, encodeImage(data));\n\n  // image file download\n  /* const canvas = document.getElementById(\"imageExportCanvas\");\n  const resultImage = canvas.toDataURL(\"image/png\");\n  if (resultImage) {\n    downloadImagefile(`result-${channelId}.png`, resultImage);\n  } */\n};\n\n// export one channel to canvas and upload to poi\nexport const uploadImageChannelToPoi = channelId => (dispatch, getState) => {\n  dispatch(clearExportImage(1));\n  dispatch(drawExportImage(channelId, 0, true));\n  // binary download\n  const data = getChannelExportData();\n\n  // export/save binary encoded image for poi\n  if (isElectron()) {\n    require(\"../utils/fileUtilsElectron\")\n      .uploadChannel(encodeImage(data), (text) => {\n        console.log(text);\n        dispatch(addToUploadLog(text));\n      });\n  }\n};\n\n// during animation or for upload\n// get image data from export canvas within an interval\n// assuming all active channels are on the canvas\n// to acoid retreiving the same frame twice\n// we use ceil on the start idx and floor on the end idx\n// if fromTime and toTime are undefined: get complete canvas\nexport const getChannelExportData = ((fromTime, toTime, sampleRate) => {\n  const exportCanvas = document.getElementById(\"imageExportCanvas\");\n  if (exportCanvas) {\n    const exportCc = exportCanvas.getContext(\"2d\");\n    const fromIdx = fromTime ? secondsToSamples(fromTime, sampleRate) : 0;\n    const toIdx = toTime ? secondsToSamples(toTime, sampleRate, false) : exportCanvas.width; // floor\n    const width = toIdx - fromIdx;\n    if (width > 0) {\n      return exportCc.getImageData(fromIdx, 0, width, exportCanvas.height);\n    }\n  }\n  return {\n    width: 0,\n    height: 0,\n    data: [],\n  };\n});\n\n// cancel any upload to poi (firmware or show)\nexport const cancelUpload = () => (dispatch, getState) => {\n  if (isElectron()) {\n    require(\"../utils/fileUtilsElectron\")\n      .killCurrentProcess();\n  }\n};\n\nexport const updateFirmware = () => (dispatch, getState) => {\n  if (isElectron()) {\n    require(\"../utils/fileUtilsElectron\")\n      .updateFirmware((text) => {\n        console.log(text);\n        dispatch(addToUploadLog(text));\n      });\n  } else {\n    console.error(\"Firmware update only implemented for Electron.\");\n  }\n\n};\n\n// Audio file loading\n\nconst loadAudioStarted = startInfo => ({\n  type: LOAD_AUDIO_STARTED\n});\n\nconst loadAudioSuccess = channelInfo => ({\n  type: LOAD_AUDIO_SUCCESS\n});\n\nconst loadAudioFailure = errorInfo => ({\n  type: LOAD_AUDIO_FAILURE,\n  payload: errorInfo\n});\n\n// load audio file to channel\nexport const loadAudioFromFile = (audioFile, audioContext) => {\n  return (dispatch, getState) => {\n    dispatch(loadAudioStarted());\n    console.log(\"Reading \" + audioFile.name + \"...\");\n\n    return readAudioFile(audioFile, audioContext)\n      .then((audioBuffer) => {\n        const channelInfo = {\n          type: \"audio\",\n          playState: \"stopped\", // TODO: remove\n          src: audioFile.name,\n          offset: 0,\n          sampleRate: audioBuffer.sampleRate,\n          gain: 1.0,\n          buffer: audioBuffer,\n          duration: audioBuffer.duration,\n          active: true, // TODO: remove\n          parts: [],\n        };\n        // console.log(channelInfo);\n        dispatch(addChannel(channelInfo));\n        dispatch(loadAudioSuccess());\n        console.log(\"File read.\");\n      })\n      .catch(err => {\n        console.error(err);\n        return dispatch(loadAudioFailure({\n          err\n        }));\n      });\n  };\n};\n","import { normalize } from \"normalizr\";\nimport {\n  UPDATE_CHANNEL, ADD_CHANNEL, DELETE_CHANNEL, CLEAR_CHANNELS,\n  SET_CHANNEL_ACTIVE, SET_CHANNEL_INACTIVE, PLAY_CHANNELS,\n  STOP_CHANNELS, STOP_CHANNEL,\n} from \"./types\";\n\nimport { getImageDuration } from \"../reducers/imageListReducer\";\nimport { defaultSampleRate } from \"../components/ImageListContainer\";\nimport { drawExportImage, clearExportImage } from \"./ioActions\";\nimport { createPart, deletePart } from \"./partActions\";\nimport { deleteMarker } from \"./markerActions\";\nimport { toggleEntitySelection } from \"./entityActions\";\nimport {\n  getMaxChannelDuration, channelExists, getDenormalizedChannel,\n  achannelSchema, getActiveChannelIds, getChannelPartIds,\n} from \"../reducers/channelReducer\";\nimport { pixelsToSeconds } from \"../utils/conversions\";\nimport { getResolution } from \"../reducers/viewReducer\";\n\n\n// first id will be 1 to avoid falsy ids\nlet lastChannelIdCount = 0;\n\nfunction generateId(channelType) {\n  // simple generator :-)\n  // other options: cuid or uuid\n  lastChannelIdCount++;\n  return \"channel-\" + channelType + \"-\" + lastChannelIdCount.toString();\n}\n\n// should only be used with care (e.g. in tests)\nexport function _resetId() {\n  lastChannelIdCount = 0;\n}\nexport function _setInitialChannelIdCount(newCount) {\n  lastChannelIdCount = newCount;\n}\n\nconst _addChannel = (channelInfo) => ({\n  type: ADD_CHANNEL,\n  payload: normalize(channelInfo, achannelSchema),\n});\n\n// add channel with channelInfo containing complete \n// denormalized channel information\nexport const addChannel = (channelInfo) => {\n  return (dispatch, getState) => {\n\n    // check requirements for channels\n    if (channelInfo.sampleRate &&\n      channelInfo.duration &&\n      Array.isArray(channelInfo.parts) &&\n\n      ((channelInfo.type === \"image\")\n        ||\n        (channelInfo.type === \"audio\" &&\n          channelInfo.buffer && channelInfo.src)\n      )) {\n\n      // add tags that are not usually externalized\n      channelInfo.gain = channelInfo.gain || 1;\n      channelInfo.channelId = generateId(channelInfo.type);\n      // parts need to be at least 5 pixel wide when resizing\n      channelInfo.minPartDuration = pixelsToSeconds(5, getResolution(getState()), channelInfo.sampleRate);\n      // snap distance is 10 pixels (for each resolution)\n      channelInfo.snapDist = pixelsToSeconds(10, getResolution(getState()), channelInfo.sampleRate);\n\n      // add channel with new channel id, but without parts yet\n      const parts = channelInfo.parts;\n      dispatch(_addChannel({\n        ...channelInfo,\n        parts: [],\n      }));\n\n      // add parts (will also add it to the channel) \n      // audio channels have no parts and simply skipped this\n      parts.forEach((part) => {\n        dispatch(createPart({\n          ...part,\n          channelId: channelInfo.channelId,\n        }, false)); // do not update selection for performance reasons\n      });\n\n      dispatch(setChannelActive(channelInfo.channelId));\n      return channelInfo.channelId;\n    }\n\n    console.error(\"cannot add incomplete channel:\", channelInfo);\n    return null;\n  };\n};\n\n// create an empty image channel\nexport const createImageChannel = () => {\n  return (dispatch, getState) => {\n    // we extend the duration to the longest channel\n    const duration = Math.max(10, getMaxChannelDuration(getState()));\n    // add required fields\n    return dispatch(addChannel({\n      type: \"image\",\n      sampleRate: defaultSampleRate,\n      duration,\n      parts: [],\n    }));\n  };\n};\n\nconst _deleteChannel = (channelId) => ({\n  type: DELETE_CHANNEL,\n  // no normalization required since we can achieve this with channelId alone\n  payload: channelId,\n});\n\nexport const deleteChannel = (channelId) => {\n  return (dispatch, getState) => {\n    // ensure we have what we need\n    // so reducers do not need to check assumptions\n\n    if (channelId != null && channelExists(getState(), channelId)) {\n      // first delete parts & markers of channel\n      getChannelPartIds(getState(), channelId)\n        .forEach((partId) => {\n          dispatch(deletePart(partId));\n        });\n\n      // then delete channel      \n      dispatch(_deleteChannel(channelId));\n    } else {\n      console.error(\"cannot remove non-existing channelId:\", channelId);\n    }\n  };\n};\n\nconst _updateChannel = (channelInfo) => ({\n  type: UPDATE_CHANNEL,\n  payload: channelInfo\n});\n\nexport const updateChannel = (channelInfo) => {\n  return (dispatch, getState) => {\n\n    const { channelId, ...updateInfo } = channelInfo;\n\n    if (channelId != null && channelExists(getState(), channelId)\n      && updateInfo) {\n      return dispatch(_updateChannel(channelInfo));\n    } else {\n      console.error(\"cannot update channel:\", channelInfo);\n    }\n  };\n};\n\nexport const clearChannels = () => ({\n  type: CLEAR_CHANNELS\n});\n\nexport const setChannelActive = (channelId) => ({\n  type: SET_CHANNEL_ACTIVE,\n  payload: channelId\n});\n\nexport const setChannelInactive = (channelId) => ({\n  type: SET_CHANNEL_INACTIVE,\n  payload: channelId\n});\n\nexport const playTheChannels = (channelIds) => ({\n  type: PLAY_CHANNELS,\n  payload: channelIds\n});\n\nexport const stopChannel = (channelId) => ({\n  type: STOP_CHANNEL,\n  payload: channelId,\n});\n\nexport const stopChannels = () => ({\n  type: STOP_CHANNELS\n});\n\nexport const playActiveChannels = () => {\n  return (dispatch, getState) => {\n    const chs = getActiveChannelIds(getState());\n    dispatch(playTheChannels(chs));\n  };\n};\n\nexport const playChannelAndImage = () => {\n  return (dispatch, getState) => {\n    const activeImageChannels = getActiveChannelIds(getState(), \"image\");\n    dispatch(clearExportImage(activeImageChannels.length));\n    activeImageChannels.map((channelId, idx) => dispatch(drawExportImage(channelId, idx)));\n    dispatch(playActiveChannels());\n  };\n};\n\nexport const duplicateImageChannel = (channelId) => {\n  return (dispatch, getState) => {\n\n    const ch = getDenormalizedChannel(getState(), channelId);\n    return dispatch(addChannel(ch));\n  };\n};\n\nexport const duplicateChannel = (channelId) => {\n  return (dispatch, getState) => {\n    const ch = getDenormalizedChannel(getState(), channelId);\n    dispatch(addChannel(ch));\n  };\n};\n\n// expected type:\n// partInfo: {imageId, channelId, offset, duration}\nexport const insertNewPart = (partInfo) => {\n  return (dispatch, getState) => {\n\n    // remove insertion marker\n    dispatch(deleteMarker(\"insert\"));\n\n    const duration = getImageDuration(\n      getState(), partInfo.imageId);\n\n    // creates part and adds it to the channel\n    const pId = dispatch(createPart({\n      ...partInfo,\n      duration\n    }));\n\n    // select the new part\n    dispatch(toggleEntitySelection(pId));\n  };\n};\n","import React, { Component } from \"react\";\nimport { connect } from \"react-redux\";\nimport PropTypes from \"prop-types\";\n\nimport Header from \"./Header\";\n\nimport {\n  playChannelAndImage, setChannelActive, setChannelInactive,\n  createImageChannel, stopChannels\n} from \"../actions/channelActions\";\nimport { saveShow, loadShowFromFile, updateFirmware, loadAudioFromFile } from \"../actions/ioActions\";\nimport { setResolution } from \"../actions/viewActions\";\nimport { deleteSelectedEntities, copyParts, pasteParts, } from \"../actions/entityActions\";\n\nimport { getAllChannelIds, allChannelsStopped } from \"../reducers/channelReducer\";\nimport { anyEntitySelected, getEntitiesIdsToCopy } from \"../reducers/entityReducer\";\n\nwindow.AudioContext = window.AudioContext || window.webkitAudioContext;\nconst audioContext = window.AudioContext && new window.AudioContext();\n\nconst resolutions = [4000, 2000, 1000, 500, 250, 125, 80, 40, 20, 10, 5]; // in pixels / sec\nconst defaultResolutionIdx = 6;\n\nclass HeaderContainer extends Component {\n\n  constructor(props) {\n    super(props);\n    this.resolutionIdx = defaultResolutionIdx;\n  }\n\n  resetZoom = () => {\n    this.resolutionIdx = defaultResolutionIdx;\n    this.props.setResolution(\n      resolutions[this.resolutionIdx]\n    );\n  }\n\n  zoomIn = () => {\n    this.resolutionIdx = Math.min(Math.max(parseInt(this.resolutionIdx) - 1, 0), resolutions.length - 1);\n    this.props.setResolution(\n      resolutions[this.resolutionIdx]\n    );\n  }\n\n  zoomOut = () => {\n    this.resolutionIdx = Math.min(Math.max(parseInt(this.resolutionIdx) + 1, 0), resolutions.length - 1);\n    this.props.setResolution(\n      resolutions[this.resolutionIdx]\n    );\n  }\n\n  render() {\n\n    return (\n      <Header { ...this.props }\n        zoomIn={ this.zoomIn }\n        zoomOut={ this.zoomOut } />\n    );\n  }\n}\n\nconst mapStateToProps = state => ({\n  channelIds: getAllChannelIds(state),\n  entitySelected: anyEntitySelected(state),\n  hasPartsToCopy: (getEntitiesIdsToCopy(state).length > 0),\n  enablePlay: Boolean(getAllChannelIds(state).length > 0 && allChannelsStopped(state)),\n  enableStop: Boolean(getAllChannelIds(state).length && !allChannelsStopped(state)),\n});\n\nconst mapDispatchToProps = dispatch => ({\n  saveShow: () => dispatch(saveShow()),\n  loadShowFromFile: (showFile) => dispatch(loadShowFromFile(showFile)),\n  loadAudioFromFile: (audioFile) => dispatch(loadAudioFromFile(audioFile, audioContext)),\n  createImageChannel: () => dispatch(createImageChannel()),\n  playChannelAndImage: (channelId) => dispatch(playChannelAndImage(channelId)),\n  stopChannel: () => dispatch(stopChannels()),\n  setResolution: (resolution) => dispatch(setResolution(resolution)),\n  deleteSelectedEntities: () => dispatch(deleteSelectedEntities()),\n  setChannelActive: (channelId) => dispatch(setChannelActive(channelId)),\n  setChannelInactive: (channelId) => dispatch(setChannelInactive(channelId)),\n  copyParts: () => dispatch(copyParts()),\n  pasteParts: () => dispatch(pasteParts()),\n  updateFirmware: () => dispatch(updateFirmware()),\n});\n\nHeaderContainer.propTypes = {\n  setResolution: PropTypes.func.isRequired,\n  deleteSelectedEntities: PropTypes.func.isRequired,\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(HeaderContainer);\n","import React, { Component } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport styled /*, { withTheme } */ from \"styled-components\";\r\nimport { withStyles } from \"@material-ui/core/styles\";\r\nimport { Tooltip, IconButton, } from \"@material-ui/core\";\r\n\r\nimport RestoreImagesIcon from \"@material-ui/icons/CloudDownload\";\r\nimport SaveImagesIcon from \"@material-ui/icons/CloudUpload\";\r\nimport ClearStoreIcon from \"@material-ui/icons/CloudOff\";\r\nimport ClearImagesIcon from \"@material-ui/icons/Clear\";\r\n\r\nconst ImageControlWrapper = styled.div`\r\n  display: flex\r\n  justify-content: center;\r\n  flex-direction: row;\r\n  margin: 0;\r\n  padding: 0 20px;\r\n`;\r\n\r\nconst styles = theme => ({\r\n  root: {\r\n    color: \"white\",\r\n  },\r\n  formControl: {\r\n    margin: theme.spacing(1),\r\n    minWidth: 80,\r\n  }\r\n});\r\n\r\n\r\nexport class ImageControl extends Component {\r\n\r\n  render() {\r\n\r\n    const { loadImagesFromStorage, saveImagesToStorage, clearImagesfromStorage, clearImageList } = this.props;\r\n\r\n    return (\r\n      <ImageControlWrapper>\r\n        <Tooltip title=\"Restore images from store\">\r\n          <IconButton color=\"primary\"\r\n              onClick={ loadImagesFromStorage }>\r\n            <RestoreImagesIcon />\r\n          </IconButton>\r\n        </Tooltip>\r\n        <Tooltip title=\"Save images to store\">\r\n          <IconButton color=\"primary\"\r\n              onClick={ saveImagesToStorage }>\r\n            <SaveImagesIcon />\r\n          </IconButton>\r\n        </Tooltip>\r\n        <Tooltip title=\"Clear store\">\r\n          <IconButton color=\"primary\"\r\n              onClick={ clearImagesfromStorage }>\r\n            <ClearStoreIcon />\r\n          </IconButton>\r\n        </Tooltip>\r\n        <Tooltip title=\"Clear images\">\r\n          <IconButton color=\"primary\"\r\n              onClick={ clearImageList }>\r\n            <ClearImagesIcon />\r\n          </IconButton>\r\n        </Tooltip>\r\n      </ImageControlWrapper>\r\n      );\r\n  }\r\n}\r\n\r\nImageControl.propTypes = {\r\n  loadImagesFromStorage: PropTypes.func.isRequired,\r\n  saveImagesToStorage: PropTypes.func.isRequired,\r\n  clearImagesfromStorage: PropTypes.func.isRequired,\r\n  clearImageList: PropTypes.func.isRequired,\r\n\r\n};\r\n\r\nexport default withStyles(styles, {\r\n  withTheme: true\r\n})(ImageControl);\r\n","import React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { connect } from \"react-redux\";\n\nimport { loadImagesFromStorage, saveImagesToStorage, clearImagesfromStorage, clearImageList } from \"../actions/imageListActions\";\nimport ImageControl from \"./ImageControl\";\n\nclass ImageControlContainer extends Component {\n\n  render() {\n    return ( <ImageControl { ...this.props } /> );\n  }\n}\n\nconst mapStateToProps = state => ({\n});\n\nconst mapDispatchToProps = dispatch => ({\n  loadImagesFromStorage: () => dispatch(loadImagesFromStorage()),\n  saveImagesToStorage: () => dispatch(saveImagesToStorage()),\n  clearImagesfromStorage: () => dispatch(clearImagesfromStorage()),\n  clearImageList: () => dispatch(clearImageList()),\n});\n\nImageControlContainer.propTypes = {\n  loadImagesFromStorage: PropTypes.func.isRequired,\n  saveImagesToStorage:PropTypes.func.isRequired,\n  clearImageList: PropTypes.func.isRequired,\n  clearImagesfromStorage: PropTypes.func.isRequired,\n};\n\n\nexport default connect(mapStateToProps, mapDispatchToProps)(ImageControlContainer);\n","import React, { Fragment } from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport styled, { withTheme } from \"styled-components\";\nimport { Menu, MenuItem } from \"@material-ui/core\";\n\n\nconst ImageProgress = styled.div`\n  position: absolute;\n  background: ${props => props.theme.waveProgressColor};\n  width: 1px;\n  left: ${props => props.progress}px;\n  height: 100%;\n  border-right: 1px solid ${props => props.theme.waveProgressBorderColor};\n`;\n\nconst ImageMarker = styled.div`\n  position: absolute;\n  background: ${props => props.color || props.theme.markerColor};\n  width: 2px;\n  left: ${props => props.markerPos}px;\n  height: 100%;\n  cursor: ${props => props.cursor};\n  z-index: ${props => props.zIndex};\n`;\n\nconst RangeSelection = styled.div`\n  position: absolute;\n  left: ${props => props.selection.from}px;\n  background: ${props => props.selection.type === \"temp\" ? props.theme.tempSelectionColor :\n    props.theme.selectionColor};\n  width: ${props => props.selection.to - props.selection.from}px;\n  height: 100%;\n  border: 1px solid ${props => props.theme.selectionColor};\n`;\n\n\nfunction ChannelMarkers(props) {\n\n  const [anchorEl, setAnchorEl] = React.useState(null);\n\n  const openContextMenu = event => {\n    setAnchorEl(event.currentTarget);\n  };\n\n  const closeContextMenu = () => {\n    setAnchorEl(null);\n  };\n\n  const handleRemoveMarker = (anchorEl) => {\n    const markerId = anchorEl.getAttribute(\"data-markerid\");\n    props.deleteMarker(markerId);\n    // make sure no insert marker exists for the first moment\n    // to not confuse user\n    props.deleteMarker(\"insertTimeScaleId\");\n    closeContextMenu();\n  };\n\n  const { channelId, progress, selection, markers, theme, } = props;\n\n  const progressElem = progress ?\n    (<ImageProgress className=\"Progress\"\n      progress={ progress }\n      theme={ theme } />)\n    : null;\n\n  const selectionElem = selection && selection.from && selection.to ?\n    (<RangeSelection\n      className=\"Selection\"\n      selection={ selection }\n      theme={ theme } />)\n    : null;\n\n  const markerElems = markers && Array.isArray(markers) ?\n    markers.map((marker) => {\n      let color = theme.markerColor;\n      let cursor = \"default\";\n      let withContextMenu = false;\n      let zIndex = 1;\n      // marker color depends on type (insert / normal), selection status\n      //  and whether the part belongs to this channel\n      if (marker.type === \"insert\") {\n        color = theme.insertMarkerColor;\n      } else if (marker.type === \"insertTimeScale\") {\n        color = theme.insertMarkerColor;\n        cursor = \"copy\"; // with '+' sign\n      } else if (marker.type === \"timeScale\") {\n        cursor = \"ew-resize\";\n        withContextMenu = true;\n        zIndex = 10; // highest: move/remove is still possible\n      } else if (marker.type === \"selected\" && marker.channelId === channelId) {\n        color = theme.selectedMarkerColor;\n        cursor = \"col-resize\";\n      } else if (marker.type === \"selected\") {\n        color = theme.selectedMarkerColorOther;\n      } else if (marker.channelId !== channelId) {\n        color = theme.markerColorOther;\n      }\n\n      const markerProps = {\n        key: marker.markerId,\n        className: \"Marker\",\n        markerPos: marker.pos,\n        onContextMenu: withContextMenu ? openContextMenu : null,\n        color,\n        cursor,\n        theme,\n        \"data-markerid\": marker.markerId,\n        \"data-markertype\": marker.type,\n        \"data-partid\": marker.partId,\n        zIndex,\n      };\n      return (<ImageMarker { ...markerProps } />);\n\n    }) : null;\n\n  const contextMenu = (<Menu\n    id=\"simple-menu\"\n    anchorEl={ anchorEl }\n    keepMounted\n    open={ Boolean(anchorEl) }\n    onClose={ closeContextMenu }\n  >\n    <MenuItem onClick={ () =>\n      handleRemoveMarker(anchorEl) }>Remove marker</MenuItem>\n  </Menu>);\n\n  return (\n    <Fragment>\n      {progressElem}\n      {selectionElem}\n      {markerElems}\n      {contextMenu}\n    </Fragment>\n  );\n}\n\nChannelMarkers.propTypes = {\n  channelId: PropTypes.string,\n\n  progress: PropTypes.number,\n  cursorPos: PropTypes.number,\n  selection: PropTypes.exact({\n    from: PropTypes.number,\n    to: PropTypes.number,\n    type: PropTypes.string,\n  }).isRequired,\n  markers: PropTypes.arrayOf(PropTypes.exact({\n    markerId: PropTypes.string.isRequired,\n    type: PropTypes.string.isRequired,\n    pos: PropTypes.number.isRequired,\n    channelId: PropTypes.string,\n    partId: PropTypes.string,\n  })).isRequired,\n\n  deleteMarker: PropTypes.func.isRequired,\n\n  theme: PropTypes.object,\n};\n\nChannelMarkers.defaultProps = {\n  // all x pixel values are from 0 regardless of offset\n  // width in CSS pixels of the progress on the channel. (null: do not draw)\n  progress: null,\n  // position of the selection in CSS pixels from the left of channel (null: do not draw)\n  selection: null,\n  // positions of the markers in CSS pixels from the left of channel (null: do not draw)\n  markers: [],\n};\n\nexport default withTheme(ChannelMarkers);\n","import React, { Component } from \"react\";\nimport { connect } from \"react-redux\";\nimport { cloneDeep } from \"lodash\";\n\nimport ChannelMarkers from \"./ChannelMarkers\";\nimport { getAllMarkerIds, getMarker } from \"../reducers/markerReducer\";\nimport { getSelectionRange, getResolution, getSelectedImageChannelId } from \"../reducers/viewReducer\";\nimport { secondsToPixels } from \"../utils/conversions\";\nimport { deleteMarker } from \"../actions/markerActions\";\n\nclass ChannelMarkersContainer extends Component {\n\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      error: null\n    };\n  }\n\n  componentDidCatch(error, state) {\n    this.setState({\n      error\n    });\n  }\n\n  render() {\n\n    if (this.state.error) {\n      return (\n        <div>\n          <p> ERROR! Cannot continue. </p>\n          {this.state.error.message ? <p>\n            {this.state.error.message} </p> : null}\n          {this.state.error.stack ? <p>\n            {this.state.error.stack} </p> : null}\n        </div>\n      );\n    }\n\n    return (\n      <ChannelMarkers { ...this.props }\n        className=\"ChannelMarkers\" />\n    );\n  }\n}\n\nconst mapStateToProps = (state, props) => {\n\n  const { channelId, progress } = props;\n\n  const resolution = getResolution(state);\n  const selectedChannelId = getSelectedImageChannelId(state);\n\n  // time to pixels\n  const offsetPx = 0;\n\n  //TODO: get progress directly (not thru channel)\n  const progressPx = progress ? secondsToPixels(progress, resolution) - offsetPx : 0;\n  const selection = getSelectionRange(state);\n  const selectionPx = selection ? {\n    from: selection.from ? secondsToPixels(selection.from, resolution) - offsetPx : 0,\n    to: selection.to ? secondsToPixels(selection.to, resolution) - offsetPx : 0,\n    type: selection.type\n  } : null;\n\n  const markerIds = getAllMarkerIds(state);\n  const markersPx = [];\n  markerIds.forEach((markerId) => {\n    const marker = cloneDeep(getMarker(state, markerId));\n    marker.pos = marker.pos ? secondsToPixels(marker.pos, resolution) - offsetPx : 0;\n    markersPx.push(marker);\n  });\n\n  return {\n    channelId,\n    progress: progressPx,\n    markers: markersPx,\n    selection: selectionPx,\n    selected: channelId === selectedChannelId,\n  };\n};\n\nconst mapDispatchToProps = dispatch => ({\n  deleteMarker: (markerId) => dispatch(deleteMarker(markerId)),\n});\n\n\nexport default connect(mapStateToProps, mapDispatchToProps)(ChannelMarkersContainer);\n","\nimport { useState } from 'react';\nimport { useDispatch } from 'react-redux'\nimport { deleteSelectedEntities, toggleEntitySelection, toggleInitialEntitySelection, toggleMultiEntitySelection } from '../actions/entityActions';\nimport { moveSelectedParts, resizePart, selectInInterval } from '../actions/partActions';\nimport { deselectRange, selectImageChannel, selectRange } from '../actions/viewActions';\n\n// handles all mouse events for the move action for the parts in the channel\n// gestures: click to select, drag to move\n\nexport function useChannelMouseEvent(channelId) {\n\n  const [fromX, setFromX] = useState(null);\n  //const [channelId, setChannelId] = useState(null);\n  const [partId, setPartId] = useState(null);\n  const [markerId, setMarkerId] = useState(null);\n  const [keyAtMouseDown, setKeyAtMouseDown] = useState(null);\n  // possible actions: anyMouseAction, moveResize, selectPartInRange, selectRange\n  const [currAction, setCurrAction] = useState(null);\n  const dispatch = useDispatch();\n\n\n  // central mouse & key event dispatcher\n  // TimeToPixels HOC wraps the Channel: x pos is in secs\n  function handleChannelMouseEvent(eventName, evInfo) {\n    // console.log(eventName, currAction);\n    const key = getKey(eventName);\n\n    if (eventName === \"keyDown\") {\n      handleKeyDown(evInfo);\n    }\n    else if (eventName.includes(\"mouseDown\")) {\n      handleActionStart(evInfo, key);\n    }\n    else if (eventName.includes(\"mouseMove\")) {\n      if (currAction) {\n        handleMoveTo(evInfo, false);\n      }\n    }\n    else if (eventName.includes(\"mouseUp\")) {\n      if (currAction === \"anyMouseAction\") {\n        // just a simple click (no move)\n        if (eventName === \"ctrl-mouseUp\") {\n          handleMultiSelect(evInfo);\n        } else {\n          handleToggleSelection(evInfo);\n        }\n        resetAction();\n      } else if (currAction) {\n        handleMoveTo(evInfo, true);\n      }\n    }\n    else if (eventName.includes(\"mouseLeave\")) {\n      if (currAction) {\n        handleMoveTo(evInfo, true);\n      }\n    }\n  }\n\n  function getKey(eventName) {\n    const keys = eventName.split(\"-\");\n    keys.pop();\n    return keys.length ? keys.join(\"-\") : null;\n  }\n\n  function resetAction() {\n    if (currAction !== \"selectRange\") {\n      dispatch(deselectRange());\n    }\n    setFromX(null);\n    // setChannelId(null);\n    setPartId(null);\n    setMarkerId(null);\n    setKeyAtMouseDown(null);\n    setCurrAction(null);\n  }\n\n  function handleKeyDown(evInfo) {\n    if (evInfo.key === \"Delete\" || evInfo.key === \"Backspace\") {\n      dispatch(deleteSelectedEntities());\n    }\n  }\n\n  // init for any mouse action\n  function handleActionStart(evInfo, key) {\n    if (evInfo.channelId) {\n      setFromX(evInfo.x);\n      // setChannelId(evInfo.channelId);\n      setPartId(evInfo.partId);\n      setMarkerId(evInfo.markerId); // for resize\n      setKeyAtMouseDown(key);\n      setCurrAction(\"anyMouseAction\");\n      dispatch(deselectRange()); // reset from earlier actions\n\n      // start with selection (if clicked on part)...\n      if (evInfo.partId && !key) {\n        // select exclusively if not selected, do nothing when selected\n        dispatch(toggleInitialEntitySelection(evInfo.partId));\n      } // ... or zero range to give initial feedback\n      else if (!evInfo.partId) {\n        dispatch(selectRange({ from: evInfo.x, to: evInfo.x, type: \"temp\" }));\n      }\n    }\n  }\n\n  function handleMoveTo(evInfo, finalizeAction) {\n    const incrX = evInfo.x - fromX;\n    if (Math.abs(incrX) > 0) {\n\n      // only move selected when we select a part\n      if ([\"anyMouseAction\", \"moveResize\"].includes(currAction)\n        && !keyAtMouseDown\n        && fromX && partId && channelId) {\n        // console.log(`move from ${moveFromX} to ${x}`);\n        moveResizePart(incrX);\n        setFromX(evInfo.x);\n      }\n\n      else if ([\"anyMouseAction\", \"selectRange\"].includes(currAction)\n        && keyAtMouseDown === \"shift\"\n        && fromX && channelId) {\n        handleSelectRange(evInfo.x);\n      }\n\n      else if ([\"anyMouseAction\", \"selectPartInRange\"].includes(currAction)\n        && fromX && channelId) {\n        selectPartInRange(evInfo.x);\n      }\n    }\n\n    if (finalizeAction) {\n      resetAction();\n    }\n  }\n\n  function moveResizePart(incrX) {\n    if (currAction === \"anyMouseAction\") { //first time call\n      setCurrAction(\"moveResize\");\n    }\n\n    if (markerId) {\n      dispatch(resizePart({ channelId, partId, markerId, incr: incrX }));\n    } else {\n      dispatch(moveSelectedParts({ partId, incr: incrX }));\n    }\n  }\n\n  function selectPartInRange(posX) {\n    if (currAction === \"anyMouseAction\") { //first time call\n      setCurrAction(\"selectPartInRange\");\n    }\n    // console.log('selection to: ', posX);\n    const leftX = Math.min(fromX, posX);\n    const rightX = Math.max(fromX, posX);\n\n    dispatch(selectRange({ from: leftX, to: rightX, type: \"temp\" }));\n    dispatch(selectInInterval(channelId, leftX, rightX));\n  }\n\n  function handleSelectRange(posX) {\n    if (currAction === \"anyMouseAction\") { //first time call\n      setCurrAction(\"selectRange\");\n    }\n    // console.log('selection to: ', posX);\n    const leftX = Math.min(fromX, posX);\n    const rightX = Math.max(fromX, posX);\n    dispatch(selectRange({ from: leftX, to: rightX }));\n  }\n\n  function handleToggleSelection(evInfo) {\n    if (evInfo.partId) {\n      dispatch(toggleEntitySelection(evInfo.partId));\n    }\n    if (evInfo.channelId) {\n      dispatch(selectImageChannel(evInfo.channelId));\n    }\n  }\n\n  function handleMultiSelect(evInfo) {\n    dispatch(toggleMultiEntitySelection(evInfo.partId));\n  }\n\n  // return the mouse event handling function to be used in the component\n  return (eventName, evInfo) => handleChannelMouseEvent(eventName, evInfo)\n\n}","import { useState } from 'react';\nimport { useDispatch } from 'react-redux'\nimport { insertNewPart } from '../actions/channelActions';\nimport { setOrReplaceInsertMarker } from '../actions/markerActions';\nimport { setMessage } from '../actions/viewActions';\n\n// handles all mouse events for the select action \n\nexport function useDropMouseEvent() {\n\n\n  const [prevPosX, setPrevPosX] = useState(null);\n  const [prevTimestamp, setPrevTimestamp] = useState(0);\n  const dispatch = useDispatch();\n\n  // if TimeToPixels HOC wraps the Channel then pos is in secs\n  function handleMouseEvent(eventName, evInfo) {\n    //console.log(evInfo, eventName);\n    switch (eventName) {\n\n      case \"dragEnter\":\n        handleInsertMarker(evInfo);\n        break;\n\n      case \"dragOver\":\n        handleInsertMarker(evInfo);\n        break;\n\n      case \"drop\":\n        handleInsertImage(evInfo);\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  function handleInsertMarker(evInfo) {\n    // only realize marker move after some time intervals and larger steps\n    if (!prevPosX ||\n      (evInfo.timestamp - prevTimestamp > 100 && Math.abs(evInfo.x - prevPosX) > 0.01)) {\n      // console.log(evInfo.x, \" \", evInfo.timestamp, \"drag\");\n      dispatch(setOrReplaceInsertMarker(evInfo.x));\n      setPrevPosX(evInfo.x);\n      setPrevTimestamp(evInfo.timestamp);\n    }\n  }\n\n  function handleInsertImage(evInfo) {\n    // console.log(evInfo.x, \" drop\");\n    // prevent drop of images that dont come from the ImageList\n    if (evInfo.channelId && evInfo.imageId) {\n      dispatch(insertNewPart({\n        channelId: evInfo.channelId,\n        imageId: evInfo.imageId,\n        offset: evInfo.x\n      }));\n    } else {\n      dispatch(setMessage(\"You cannot drop an image directly, drop it into the image view first.\", \"error\", \"Error\"));\n    }\n    setPrevPosX(null);\n    setPrevTimestamp(0);\n  }\n\n  // return the mouse event handling function to be used in the component\n  return (eventName, evInfo) => handleMouseEvent(eventName, evInfo)\n}","import { useState } from 'react';\nimport { useDispatch } from 'react-redux'\nimport { deleteMarker, setOrReplaceMarker } from '../actions/markerActions';\n\n// handles all mouse events for the move action for the parts in the timescale component\n// gestures: drag to move\n\nexport function useTimeScaleMouseEvent() {\n\n  const [markerId, setMarkerId] = useState(null);\n  const dispatch = useDispatch();\n\n  // TimeToPixels HOC wraps the Channel: pos is in secs\n  function handleTimeScaleMouseEvent(eventName, evInfo) {\n    switch (eventName) {\n\n      case \"mouseDown\":\n        // stop move of insert marker\n        handleMoveEnd(evInfo);\n        // start move of timeScale marker\n        handleMoveStart(evInfo);\n        break;\n\n      case \"mouseUp\":\n        // create marker or stop moving marker\n        handleFinalizeMove(evInfo);\n        handleMoveEnd(evInfo);\n        break;\n\n      case \"mouseMove\":\n        handleMove(evInfo);\n        break;\n\n      case \"mouseLeave\":\n        handleMoveEnd();\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  function handleFinalizeMove(evInfo) {\n    if (markerId) {\n      // end move of this marker\n      setMarkerId(null);\n    } else {\n      // create new timeScale marker\n      const markerInfo = {\n        //markerId will be generated\n        pos: evInfo.x,\n        type: \"timeScale\"\n      };\n      dispatch(setOrReplaceMarker(markerInfo));\n    }\n  }\n\n  function handleMoveStart(evInfo) {\n    // only move timeScale markers\n    if (evInfo.markerId && evInfo.markerType === \"timeScale\") {\n      setMarkerId(evInfo.markerId);\n    }\n  }\n\n  function handleMove(evInfo) {\n    const markerInfo = markerId ?\n      {\n        pos: evInfo.x,\n        type: \"timeScale\",\n        markerId: markerId\n      } : {\n        pos: evInfo.x,\n        type: \"insertTimeScale\",\n        markerId: \"insertTimeScaleId\" // just one of this type\n      };\n    dispatch(setOrReplaceMarker(markerInfo));\n  }\n\n  function handleMoveEnd() {\n    if (!markerId) {\n      dispatch(deleteMarker(\"insertTimeScaleId\"));\n    }\n    setMarkerId(null);\n  }\n\n  // return the mouse event handling function to be used in the component\n  return (eventName, evInfo) => handleTimeScaleMouseEvent(eventName, evInfo)\n}","\n\n// handles all mouse events for the select action \n\nimport { pixelsToSeconds } from \"../utils/conversions\";\nimport { useChannelMouseEvent } from \"./useChannelMouseEvent\";\nimport { useDropMouseEvent } from \"./useDropMouseEvent\";\nimport { useTimeScaleMouseEvent } from \"./useTimeScaleMouseEvent\";\n\nexport function useMouseEvent(wrapperClassForPosition, resolution, channelId = null) {\n\n  const handleTimeScaleMouseEvent = useTimeScaleMouseEvent();\n  const handleChannelMouseEvent = useChannelMouseEvent(channelId);\n  const handleDropMouseEevent = useDropMouseEvent();\n\n  function handleEvent(eventName, e) {\n    e.preventDefault();\n\n    // collect different information to add to the event\n    const pos = eventName !== \"keyDown\" ?\n      getMouseEventPosition(e, wrapperClassForPosition, channelId) : {};\n    // transfer data is not available until drop (not on dragEnter / dragOver)\n    const imageId = e.dataTransfer && e.dataTransfer.getData(\"imageid\");\n    const duration = e.dataTransfer && Number(e.dataTransfer.getData(\"duration\"));\n    const key = e.key;\n    const shiftKey = e.shiftKey;\n    const ctrlKey = e.ctrlKey;\n\n    let adaptedEventName = eventName;\n    if (shiftKey) {\n      adaptedEventName = \"shift-\" + adaptedEventName;\n    }\n    if (ctrlKey) {\n      adaptedEventName = \"ctrl-\" + adaptedEventName;\n    }\n    const evInfo = {\n      ...pos, // x pos, channelId, partId, markerId, className\n      timestamp: e.timeStamp,\n      imageId,\n      duration,\n      key,\n    };\n    handleSpecificMouseEvent(adaptedEventName, evInfo);\n  }\n\n  // decide which mouse handler to use\n  function handleSpecificMouseEvent(eventName, evInfo) {\n    if (eventName.includes(\"drag\") || eventName.includes(\"drop\")) {\n      handleDropMouseEevent(eventName, evInfo);\n    }\n    else if (evInfo.className === \"PlaylistTimeScale\") {\n      handleTimeScaleMouseEvent(eventName, evInfo);\n    }\n    else {\n      handleChannelMouseEvent(eventName, evInfo);\n    }\n  }\n\n  function getMouseEventPosition(e, className, channelId) {\n\n    // find div with className\n    let el = e.target;\n    const partId = el.getAttribute(\"data-partid\");\n    const markerId = el.getAttribute(\"data-markerid\");\n    const markerType = el.getAttribute(\"data-markertype\");\n    let position = 0;\n    let cn = className;\n\n    while (el && el.classList && !el.classList.contains(className)) {\n      el = el.parentNode;\n    }\n\n    if (el && el.classList && el.classList.contains(className)) {\n      const parentScroll = el.parentNode ? el.parentNode.scrollLeft : 0;\n      position = Math.max(0, e.clientX - el.offsetLeft + parentScroll);\n    } else {\n      console.debug(`Event did not find ${className}`);\n      cn = null;\n    }\n\n    const x = pixelsToSeconds(position, resolution);\n\n    return {\n      x,\n      partId,\n      markerId,\n      markerType,\n      channelId,\n      className: cn,\n    };\n  }\n\n  // return the mouse event handling function to be used in the component\n  return (eventName, evInfo) => handleEvent(eventName, evInfo)\n}","import React, { useRef, useEffect } from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport styled, { withTheme } from \"styled-components\";\nimport ChannelMarkersContainer from \"./ChannelMarkersContainer\";\nimport { useMouseEvent } from \"../hooks/useMouseEvent\";\n\nconst TIME_INFO = {\n  20000: {\n    marker: 30000,\n    bigStep: 10000,\n    smallStep: 5000,\n    secondStep: 5,\n  },\n  12000: {\n    marker: 15000,\n    bigStep: 5000,\n    smallStep: 1000,\n    secondStep: 1,\n  },\n  10000: {\n    marker: 10000,\n    bigStep: 5000,\n    smallStep: 1000,\n    secondStep: 1,\n  },\n  5000: {\n    marker: 5000,\n    bigStep: 1000,\n    smallStep: 500,\n    secondStep: 1 / 2,\n  },\n  2500: {\n    marker: 2000,\n    bigStep: 1000,\n    smallStep: 500,\n    secondStep: 1 / 2,\n  },\n  1500: {\n    marker: 2000,\n    bigStep: 1000,\n    smallStep: 200,\n    secondStep: 1 / 5,\n  },\n  700: {\n    marker: 1000,\n    bigStep: 500,\n    smallStep: 100,\n    secondStep: 1 / 10,\n  },\n};\n\nfunction getScaleInfo(resolution) {\n  let keys = Object.keys(TIME_INFO).map(item => parseInt(item, 10));\n\n  // make sure keys are numerically sorted.\n  keys = keys.sort((a, b) => a - b);\n\n  for (let i = 0; i < keys.length; i += 1) {\n    if (48000 / resolution <= keys[i]) {\n      return TIME_INFO[keys[i]];\n    }\n  }\n\n  return TIME_INFO[keys[0]];\n}\n\nfunction formatTime(milliseconds) {\n  const seconds = milliseconds / 1000;\n  let s = seconds % 60;\n  const m = (seconds - s) / 60;\n\n  if (s < 10) {\n    s = `0${s}`;\n  }\n\n  return `${m}:${s}`;\n}\n\nconst PlaylistTimeScale = styled.div`\n  width: ${props => props.cssWidth}px;\n  position: relative;\n  left: 0;\n  right: 0;\n  height: 30px;\n  background: #2c387e;\n  color: white;\n  cursor: default\n`;\n\nconst PlaylistTimeScaleScroll = styled.div`\n  position: absolute;\n  width: ${props => props.cssWidth}px;\n  height: 100%;\n`;\n\nconst TimeTicks = styled.canvas`\n  position: absolute;\n  width: ${props => props.cssWidth}px;\n  height: ${props => props.timeScaleHeight}px;\n  left: 0;\n  right: 0;\n  bottom: 0;\n`;\n\nconst TimeStamp = styled.div`\n  left: ${props => props.pix}px;\n  position: absolute;\n`;\n\nfunction TimeScale(props) {\n\n  const { maxWidth, resolution, scale, timeScaleHeight, theme } = props;\n\n  const canvasRef = useRef(null);\n\n  const scaleInfo = getScaleInfo(resolution);\n  const canvasInfo = {};\n  const timeMarkers = [];\n  let counter = 0;\n\n  useEffect(() => {\n    draw();\n  })\n\n  const handleMouseEvent = useMouseEvent(\"PlaylistTimeScale\", resolution);\n\n  function draw() {\n    if (canvasRef) {\n      const ctx = canvasRef.current.getContext(\"2d\");\n\n      ctx.clearRect(0, 0, canvasRef.width, canvasRef.height);\n      ctx.fillStyle = theme.timeColor;\n      ctx.scale(scale, scale);\n\n      Object.keys(canvasInfo).forEach((x) => {\n        const scaleHeight = canvasInfo[x];\n        const scaleY = timeScaleHeight - scaleHeight;\n        ctx.fillRect(x, scaleY, 1, scaleHeight);\n      });\n    }\n  }\n\n  for (let i = 0; i < maxWidth; i += (resolution * scaleInfo.secondStep)) {\n    const pix = Math.floor(i);\n\n    // put a timestamp every 30 seconds.\n    if (scaleInfo.marker && (counter % scaleInfo.marker === 0)) {\n      const timestamp = formatTime(counter);\n      timeMarkers.push(\n        <TimeStamp\n          key={timestamp}\n          pix={pix}>\n          {timestamp}\n        </TimeStamp>);\n      canvasInfo[pix] = timeScaleHeight;\n    } else if (scaleInfo.bigStep && (counter % scaleInfo.bigStep === 0)) {\n      canvasInfo[pix] = Math.floor(timeScaleHeight / 2);\n    } else if (scaleInfo.smallStep && (counter % scaleInfo.smallStep === 0)) {\n      canvasInfo[pix] = Math.floor(timeScaleHeight / 5);\n    }\n\n    counter += (1000 * scaleInfo.secondStep);\n  }\n\n  return (\n    <PlaylistTimeScale\n      className=\"PlaylistTimeScale\"\n      onMouseDown={(e) => handleMouseEvent(\"mouseDown\", e)}\n      onMouseUp={(e) => handleMouseEvent(\"mouseUp\", e)}\n      onMouseMove={(e) => handleMouseEvent(\"mouseMove\", e)}\n      onMouseLeave={(e) => handleMouseEvent(\"mouseLeave\", e)}\n      cssWidth={maxWidth}>\n      <PlaylistTimeScaleScroll cssWidth={maxWidth}>\n        {timeMarkers}\n        <TimeTicks cssWidth={maxWidth}\n          width={maxWidth * scale}\n          height={timeScaleHeight * scale}\n          ref={canvasRef}\n        />\n      </PlaylistTimeScaleScroll>\n      <ChannelMarkersContainer\n        className=\"ChannelMarkersContainer\"\n        theme={theme} />\n    </PlaylistTimeScale>\n  );\n\n}\n\nTimeScale.propTypes = {\n  maxWidth: PropTypes.number,\n  resolution: PropTypes.number.isRequired,\n  controlWidth: PropTypes.number,\n  theme: PropTypes.object,\n  scale: PropTypes.number,\n  timeScaleHeight: PropTypes.number,\n  handleMouseEvent: PropTypes.func.isRequired,\n};\n\n\nTimeScale.defaultProps = {\n  scale: 1, // currently always default, could use `window.devicePixelRatio`\n  // time length in seconds\n  duration: 0,\n  samplesPerPixel: 1000,\n  // sampleRate: 48000,\n  timeScaleHeight: 10,\n};\n\nexport default withTheme(TimeScale);\n","/* \r\n  Deals with time (in secs) to pixel conversion\r\n*/\r\n\r\nimport React, { PureComponent } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport { cloneDeep } from \"lodash\";\r\n\r\nimport { secondsToPixels } from \"../utils/conversions\";\r\n\r\n// HOC to support time to pixel conversion for one channel\r\nexport function timeToPixels(WrappedComponent) {\r\n  class TimeToPixels extends PureComponent {\r\n\r\n    render() {\r\n\r\n      const { resolution, offset, maxDuration, parts, ...passthruProps } = this.props;\r\n\r\n      // channel offset only used for audio buffer which does not contain parts\r\n      const offsetPx = offset ? secondsToPixels(offset, resolution) : 0;\r\n      const maxWidthPx = maxDuration ? secondsToPixels(maxDuration, resolution) : 0;\r\n      const partsPx = parts ? cloneDeep(parts) : [];\r\n      partsPx.forEach(part => {\r\n        part.offset = part.offset ? secondsToPixels(part.offset, resolution) : 0;\r\n        part.duration = part.duration ? secondsToPixels(part.duration, resolution) : 0;\r\n      });\r\n\r\n      const pixelProps = {\r\n        ...passthruProps,\r\n        offset: offsetPx,\r\n        maxWidth: maxWidthPx,\r\n        parts: partsPx,\r\n        resolution: resolution,\r\n      };\r\n\r\n      return (<WrappedComponent {...pixelProps} />);\r\n    }\r\n  }\r\n  ;\r\n\r\n  TimeToPixels.propTypes = {\r\n    resolution: PropTypes.number.isRequired,\r\n    offset: PropTypes.number,\r\n    progress: PropTypes.number,\r\n    cursorPos: PropTypes.number,\r\n    selection: PropTypes.object,\r\n    maxDuration: PropTypes.number.isRequired,\r\n    parts: PropTypes.array,\r\n    markers: PropTypes.array,\r\n  };\r\n\r\n  return TimeToPixels;\r\n}\r\n","import React, { Component, Fragment } from \"react\";\nimport PropTypes from \"prop-types\";\nimport styled, { withTheme } from \"styled-components\";\nimport deepEqual from \"fast-deep-equal\";\n\nconst MAX_CANVAS_WIDTH = 1000;\n\nconst ImageCanvas = styled.canvas`\n  float: left;\n  position: relative;\n  margin: 0;\n  padding: 0;\n  width: ${props => props.cssWidth}px;\n  height: ${props => props.height}px;\n`;\n\nconst CanvasRefImage = styled.img`\n  display: none;\n`;\n\nconst ImageCanvases = styled.div`\n  float: left;\n  position: absolute;\n  left: ${props => props.offset}px;\n  cursor: ${props => props.cursor};\n  border-left: 1px solid ${props => props.theme.markerColor};\n  border-right:  1px solid ${props => props.theme.markerColor};\n`;\n\nclass ImageChannel extends Component {\n  constructor(props) {\n    super(props);\n    // factor for width to facilitate drawing: pixels / sample\n    // alternative: calculate resolution / sampleRate in container and pass it in\n    this.widthFactor = 1;\n    this.canvaseRefs = [];\n    this.imageRefs = [];\n  }\n\n  componentDidMount() {\n    this.draw();\n  }\n\n  shouldComponentUpdate(nextProps) {\n    // shallow comparison (\"pure\") for all but parts\n    //TODO: find a way to make shallow equal work\n    let doUpdate = false;\n    Object.entries(this.props).forEach(([key, val]) => {\n      if (key === \"parts\") {\n        if (!deepEqual(nextProps.parts, this.props.parts)) {\n          doUpdate = true;\n        }\n      }\n      else if (nextProps[key] !== val) {\n        doUpdate = true;\n      }\n    });\n    return doUpdate;\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    this.draw();\n    /*\n    Object.entries(this.props).forEach(([key, val]) =>\n      prevProps[key] !== val && console.log(`IC: Prop '${key}' changed`)\n    );\n    if (this.state) {\n      Object.entries(this.state).forEach(([key, val]) =>\n        prevState[key] !== val && console.log(`IC: State '${key}' changed`)\n      );\n    } */\n  }\n\n  draw() {\n    const { imageHeight, scale } = this.props;\n\n    Object.keys(this.imageRefs).forEach((idx) => {\n\n      const img = this.imageRefs[idx];\n      let canvasOffset = 0; // TODO: use cue\n      if (!img) {\n        return;\n      }\n\n      for (let c = 0; c < this.canvaseRefs[idx].length; c++) {\n        const canvas = this.canvaseRefs[idx][c];\n        if (!canvas) {\n          break;\n        }\n\n        const cc = canvas.getContext(\"2d\");\n        cc.clearRect(0, 0, canvas.width, canvas.height);\n        const imageOffset = canvasOffset / this.widthFactor[idx];\n\n        cc.scale(scale, scale);\n        if (img.src) {\n          img.onload = cc.drawImage(img, imageOffset, 0, img.width, img.height,\n            0, 0, img.width * this.widthFactor[idx], imageHeight);\n        } else {\n          cc.fillStyle = \"#FF0000\"; // red rectangle if image is missing\n          cc.fillRect(0, 0, canvas.width, imageHeight);\n        }\n        canvasOffset += MAX_CANVAS_WIDTH;\n      }\n    });\n  }\n\n  createCanvasRef(i, c) {\n    return (canvas) => {\n      if (!this.canvaseRefs[i]) {\n        this.canvaseRefs[i] = [];\n      }\n      this.canvaseRefs[i][c] = canvas;\n    };\n  }\n\n  createImageRef(i) {\n    return (image) => {\n      this.imageRefs[i] = image;\n    };\n  }\n\n  render() {\n    const { parts, imageHeight, scale, theme, images } = this.props;\n\n    // loop thru all images/parts\n    const allImageCanvases = [];\n    const allCanvasRefImages = [];\n    this.canvaseRefs = [];\n    this.imageRefs = [];\n    this.widthFactor = [];\n\n    if (parts && Array.isArray(parts)) {\n\n      parts.forEach((part) => {\n\n        const { partId, imageId, offset, duration } = {\n          ...part\n        };\n\n        const src = images[imageId].src;\n        this.widthFactor[partId] = duration / images[imageId].width;\n\n        // paint images of canvases with max with MAX_CANVAS_WIDTH\n        const canvasImages = [];\n        let totalWidth = duration; // duration in pixels\n        let canvasCount = 0;\n\n        while (totalWidth > 0) {\n          // split up image into parts of MAX_CANVAS_WIDTH\n          const currentWidth = Math.min(totalWidth, MAX_CANVAS_WIDTH);\n          const canvasImage = (\n            <ImageCanvas key={String(partId) + \"-\" + String(canvasCount)}\n              cssWidth={currentWidth}\n              width={currentWidth * scale}\n              height={imageHeight + 2}\n              ref={this.createCanvasRef(partId, canvasCount)}\n              data-partid={partId}\n              theme={theme}\n            />\n          );\n\n          canvasImages.push(canvasImage);\n          totalWidth -= currentWidth;\n          canvasCount += 1;\n        }\n        allImageCanvases.push(\n          <ImageCanvases key={partId}\n            className=\"ImageCanvases\"\n            theme={theme}\n            offset={offset}\n            cursor=\"move\">\n            {canvasImages}\n          </ImageCanvases>\n        );\n        allCanvasRefImages.push(\n          <CanvasRefImage\n            key={partId}\n            src={src}\n            className=\"hidden\"\n            ref={this.createImageRef(partId)} />\n        );\n      });\n    }\n\n    return (\n      <Fragment>\n        {allCanvasRefImages}\n        {allImageCanvases}\n      </Fragment>\n    );\n  }\n}\n\nImageChannel.propTypes = {\n  theme: PropTypes.object,\n  scale: PropTypes.number,\n  maxWidth: PropTypes.number,\n\n  parts: PropTypes.arrayOf(\n    PropTypes.shape({\n      partId: PropTypes.string.isRequired,\n      offset: PropTypes.number, // might be zero\n      duration: PropTypes.number.isRequired,\n    })),\n  images: PropTypes.object.isRequired,\n  imageHeight: PropTypes.number, // currently only default\n};\n\nImageChannel.defaultProps = {\n  scale: 1,  // currently always default, could use `window.devicePixelRatio`\n  offset: 0,\n  maxWidth: 800,\n\n  // height in CSS pixels of each canvas element an image is on.\n  imageHeight: 90, // multiple of num LEDs\n};\n\nexport default withTheme(ImageChannel);\n","import React, { PureComponent, Fragment } from \"react\";\nimport PropTypes from \"prop-types\";\nimport styled, { withTheme } from \"styled-components\";\n\nconst MAX_CANVAS_WIDTH = 1000;\n\nconst Waveform = styled.canvas`\n  float: left;\n  position: relative;\n  margin: 0;\n  padding: 0;\n  width: ${props => props.cssWidth}px;\n  height: ${props => props.waveHeight}px;\n`;\n\nconst WaveformCanvases = styled.div`\n  float: left;\n  position: relative;\n  left: ${props => props.offset}px;\n  background: ${props => props.theme.waveFillColor};\n`;\n\nclass Channel extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.canvases = [];\n  }\n\n  componentDidMount() {\n    this.draw();\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    this.draw();\n    /*\n    Object.entries(this.props).forEach(([key, val]) =>\n      prevProps[key] !== val && console.log(`AC Prop '${key}' changed`)\n    );\n    if (this.state) {\n      Object.entries(this.state).forEach(([key, val]) =>\n        prevState[key] !== val && console.log(`AC State '${key}' changed`)\n      );\n    }*/\n  }\n\n  draw() {\n    const { peaks, bits, waveHeight, theme, scale } = this.props;\n\n    let offset = 0;\n    for (let i = 0; i < this.canvases.length; i++) {\n      const canvas = this.canvases[i];\n      if (!canvas) {\n        break; // TODO: find out how to reset canvases on new render\n      }\n      const cc = canvas.getContext(\"2d\");\n      const h2 = waveHeight / 2;\n      const maxValue = 2 ** (bits - 1);\n\n      cc.clearRect(0, 0, canvas.width, canvas.height);\n      cc.fillStyle = theme.waveOutlineColor;\n      cc.scale(scale, scale);\n\n      const peakSegmentLength = canvas.width / scale;\n      for (let i = 0; i < peakSegmentLength; i += 1) {\n        const minPeak = peaks[(i + offset) * 2] / maxValue;\n        const maxPeak = peaks[((i + offset) * 2) + 1] / maxValue;\n\n        const min = Math.abs(minPeak * h2);\n        const max = Math.abs(maxPeak * h2);\n\n        // draw max\n        cc.fillRect(i, 0, 1, h2 - max);\n        // draw min\n        cc.fillRect(i, h2 + min, 1, h2 - min);\n      }\n\n      offset += MAX_CANVAS_WIDTH;\n    }\n  }\n\n  createCanvasRef(i) {\n    return (canvas) => {\n      this.canvases[i] = canvas;\n    };\n  }\n\n  render() {\n    const { maxWidth, waveHeight, scale, theme, offset, } = this.props;\n\n    let totalWidth = maxWidth;\n    let waveformCount = 0;\n    const waveforms = [];\n    while (totalWidth > 0) {\n      const currentWidth = Math.min(totalWidth, MAX_CANVAS_WIDTH);\n      const waveform = (\n        <Waveform key={ `${maxWidth}-${waveformCount}` }\n          cssWidth={ currentWidth }\n          width={ currentWidth * scale }\n          height={ waveHeight * scale }\n          waveHeight={ waveHeight }\n          ref={ this.createCanvasRef(waveformCount) }\n        />);\n\n      waveforms.push(waveform);\n      totalWidth -= currentWidth;\n      waveformCount += 1;\n    }\n\n    return (<Fragment>\n      <WaveformCanvases className=\"WaveformCanvases\"\n        theme={ theme }\n        offset={ offset }>\n        {waveforms}\n      </WaveformCanvases>\n    </Fragment>\n    );\n  }\n}\n\nChannel.propTypes = {\n  theme: PropTypes.object,\n  scale: PropTypes.number,\n  maxWidth: PropTypes.number,\n\n  offset: PropTypes.number,\n  peaks: PropTypes.object,\n  bits: PropTypes.number,\n  waveHeight: PropTypes.number, // currently only default\n};\n\nChannel.defaultProps = {\n  scale: 1, // currently always default, could use `window.devicePixelRatio`\n  offset: 0,\n  maxWidth: 0,\n\n  peaks: [],\n  bits: 0,\n  // height in CSS pixels of each canvas element a waveform is on.\n  waveHeight: 92,\n};\n\nexport default withTheme(Channel);\n","import PropTypes from \"prop-types\";\r\nimport styled, { withTheme } from \"styled-components\";\r\nimport ChannelMarkersContainer from \"./ChannelMarkersContainer\";\r\nimport ImageChannel from \"./ImageChannel\";\r\nimport AudioChannel from \"./AudioChannel\";\r\nimport { useMouseEvent } from \"../hooks/useMouseEvent\";\r\nimport { useEffect } from \"react\";\r\n\r\n// need position:relative so children will respect parent margin/padding\r\nconst ChannelWrapper = styled.div`\r\n  position: relative; \r\n  margin: 0;\r\n  padding: 0;\r\n  background: ${props => props.backgroundColor};\r\n  width: ${props => props.cssWidth}px;\r\n  height: ${props => props.height}px;\r\n  border: 1px solid ${props => props.theme.borderColor};\r\n  border-left: none;\r\n`;\r\n\r\nfunction Channel(props) {\r\n\r\n  const { channelId, imageHeight, progress, theme,\r\n    maxWidth, selected, type, offset, peaks,\r\n    bits, parts, images, resolution } = props;\r\n\r\n  const handleMouseEvent = useMouseEvent(\"ChannelWrapper\", resolution, channelId);\r\n\r\n  useEffect(() => {\r\n    document.addEventListener(\"keydown\", (e) => handleMouseEvent(\"keyDown\", e));\r\n    return () =>\r\n      document.removeEventListener(\"keydown\", (e) => (e) => handleMouseEvent(\"keyDown\", e));\r\n  })\r\n\r\n  const channelWrapperProps = {\r\n    cssWidth: maxWidth + 2, // to give room for border\r\n    theme,\r\n    height: imageHeight + 2, // to give room for border\r\n    tabIndex: 0,\r\n    backgroundColor: selected ? theme.imageBackgroundColorSelected : theme.imageBackgroundColor,\r\n  };\r\n\r\n  // separate props\r\n  const channelProps = type === \"audio\" ? {\r\n    theme,\r\n    maxWidth,\r\n    offset,\r\n    peaks,\r\n    bits,\r\n  } : {\r\n      theme,\r\n      maxWidth,\r\n      selected,\r\n      parts,\r\n      images,\r\n    };\r\n\r\n  const innerChannel = type === \"audio\"\r\n    ? <AudioChannel {...channelProps} />\r\n    : <ImageChannel {...channelProps} />;\r\n\r\n  return (\r\n    <ChannelWrapper {...channelWrapperProps} className=\"ChannelWrapper\"\r\n      onMouseDown={(e) => handleMouseEvent(\"mouseDown\", e)}\r\n      onMouseUp={(e) => handleMouseEvent(\"mouseUp\", e)}\r\n      onMouseMove={(e) => handleMouseEvent(\"mouseMove\", e)}\r\n      onMouseLeave={(e) => handleMouseEvent(\"mouseLeave\", e)}\r\n      onDragEnter={(e) => handleMouseEvent(\"dragEnter\", e)}\r\n      onDragEnd={(e) => handleMouseEvent(\"dragEnd\", e)}\r\n      onDragExit={(e) => handleMouseEvent(\"dragExit\", e)}\r\n      onDragLeave={(e) => handleMouseEvent(\"dragLeave\", e)}\r\n      onDragOver={(e) => handleMouseEvent(\"dragOver\", e)}\r\n      onDragStart={(e) => handleMouseEvent(\"dragStart\", e)}\r\n      onDrop={(e) => handleMouseEvent(\"drop\", e)}>\r\n      { innerChannel}\r\n      <ChannelMarkersContainer className=\"ChannelMarkersContainer\"\r\n        channelId={channelId}\r\n        progress={progress} theme={theme} />\r\n    </ChannelWrapper>\r\n  );\r\n\r\n}\r\n\r\nChannel.propTypes = {\r\n  channelId: PropTypes.string.isRequired,\r\n  type: PropTypes.string.isRequired,\r\n  imageHeight: PropTypes.number,\r\n  progress: PropTypes.number,\r\n  theme: PropTypes.object,\r\n  maxWidth: PropTypes.number, // max width of all channels\r\n  selected: PropTypes.bool,\r\n  handleMouseEvent: PropTypes.func.isRequired,\r\n  offset: PropTypes.number,\r\n  peaks: PropTypes.object,\r\n  bits: PropTypes.number,\r\n  parts: PropTypes.arrayOf(PropTypes.object),\r\n  images: PropTypes.object,\r\n  resolution: PropTypes.number,\r\n};\r\n\r\nChannel.defaultProps = {\r\n  maxWidth: 800, // initial width without audio\r\n  imageHeight: 90, // multiple of num LEDs\r\n};\r\n\r\nexport default withTheme(Channel);\r\n","import { FADEIN, FADEOUT, createFadeIn, createFadeOut } from \"fade-maker\";\n\nexport default class Playout {\n\n  constructor(ac, buffer) {\n    this.ac = ac;\n    this.gain = 1;\n    this.buffer = buffer;\n    this.destination = this.ac.destination;\n  }\n\n  applyFade(type, start, duration, shape = \"logarithmic\") {\n    if (type === FADEIN) {\n      createFadeIn(this.fadeGain.gain, shape, start, duration);\n    } else if (type === FADEOUT) {\n      createFadeOut(this.fadeGain.gain, shape, start, duration);\n    } else {\n      throw new Error(\"Unsupported fade type\");\n    }\n  }\n\n  applyFadeIn(start, duration, shape = \"logarithmic\") {\n    this.applyFade(FADEIN, start, duration, shape);\n  }\n\n  applyFadeOut(start, duration, shape = \"logarithmic\") {\n    this.applyFade(FADEOUT, start, duration, shape);\n  }\n\n  isPlaying() {\n    return this.source !== undefined;\n  }\n\n  getDuration() {\n    return this.buffer.duration;\n  }\n\n  setAudioContext(audioContext) {\n    this.ac = audioContext;\n    this.destination = this.ac.destination;\n  }\n\n  setUpSource() {\n    this.source = this.ac.createBufferSource();\n    this.source.buffer = this.buffer;\n\n    const sourcePromise = new Promise((resolve) => {\n      // keep track of the buffer state.\n      this.source.onended = () => {\n        this.source.disconnect();\n        this.fadeGain.disconnect();\n        this.volumeGain.disconnect();\n        this.shouldPlayGain.disconnect();\n        this.masterGain.disconnect();\n\n\n        this.source = undefined;\n        this.fadeGain = undefined;\n        this.volumeGain = undefined;\n        this.shouldPlayGain = undefined;\n        this.masterGain = undefined;\n\n        resolve();\n      };\n    });\n\n    this.fadeGain = this.ac.createGain();\n    // used for track volume slider\n    this.volumeGain = this.ac.createGain();\n    // used for solo/mute\n    this.shouldPlayGain = this.ac.createGain();\n    this.masterGain = this.ac.createGain();\n\n    this.source.connect(this.fadeGain);\n    this.fadeGain.connect(this.volumeGain);\n    this.volumeGain.connect(this.shouldPlayGain);\n    this.shouldPlayGain.connect(this.masterGain);\n    this.masterGain.connect(this.destination);\n\n    return sourcePromise;\n  }\n\n  setVolumeGainLevel(level) {\n    if (this.volumeGain) {\n      this.volumeGain.gain.value = level;\n    }\n  }\n\n  setShouldPlay(bool) {\n    if (this.shouldPlayGain) {\n      this.shouldPlayGain.gain.value = bool ? 1 : 0;\n    }\n  }\n\n  setMasterGainLevel(level) {\n    if (this.masterGain) {\n      this.masterGain.gain.value = level;\n    }\n  }\n\n  /*\n    source.start is picky when passing the end time.\n    If rounding error causes a number to make the source think\n    it is playing slightly more samples than it has it won't play at all.\n    Unfortunately it doesn't seem to work if you just give it a start time.\n  */\n  play(when, start, duration) {\n    this.source.start(when, start, duration);\n  }\n\n  stop(when = 0) {\n    if (this.source) {\n      this.source.stop(when);\n    }\n  }\n}\n","/*\r\n  HOC to support audio/image playing for one channel\r\n  also updates play progress in channel\r\n  and generates the waveform based on the audio data\r\n*/\r\n\r\nimport React, { PureComponent } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\n\r\nimport Playout from \"../player/Playout\";\r\n\r\nexport function withPlay(WrappedComponent) {\r\n\r\n  class WithPlay extends PureComponent {\r\n\r\n    constructor(props) {\r\n      super(props);\r\n      this.animationStartTime = null; // start time of progress animation timer, null means not playing\r\n      this.playStartAt = 0; // start of current play\r\n      this.playEndAt = 0; // end of current play\r\n      this.state = {\r\n        progress: null, // play progress in secs\r\n      };\r\n    }\r\n\r\n    componentDidMount() {\r\n      // audio setup\r\n      if (this.props.type === \"audio\") {\r\n        this.playout = null;\r\n        window.AudioContext = window.AudioContext || window.webkitAudioContext;\r\n        this.audioContext = new window.AudioContext();\r\n      }\r\n    }\r\n\r\n    componentDidUpdate(prevProps, prevState) {\r\n\r\n      const { playState, selection, offset } = this.props;\r\n\r\n      // start or stop playing\r\n      if (prevProps.playState !== playState) {\r\n        if (playState === \"playing\") {\r\n          this.startPlay(selection.from, selection.to, offset\r\n          );\r\n        } else if (this.isPlaying()) {\r\n          // only stopped if not already (auto)stopped\r\n          this.stopPlay();\r\n        }\r\n      }\r\n    }\r\n\r\n    componentWillUnmount() {\r\n      // clean up playout and animation\r\n      if (this.isPlaying()) {\r\n        this.stopPlay();\r\n      }\r\n    }\r\n\r\n    startPlay = (startAt, endAt, offset) => {\r\n      if (!this.playout && this.audioContext) {\r\n        this.playout = new Playout(this.audioContext, this.props.buffer);\r\n      }\r\n\r\n      // regular start at startAt\r\n      if (!this.isPlaying() && endAt >= startAt) {\r\n\r\n        // act.. values is global time interval of this channel\r\n        const actOffset = offset\r\n          ? offset\r\n          : 0;\r\n        const actStartAt = Math.max(0, startAt); // dont start before 0\r\n        const duration = this.props.buffer\r\n          ? this.props.buffer.duration\r\n          : this.props.maxDuration;\r\n        const actEndAt = endAt - startAt < 0.1\r\n          ? duration + actOffset\r\n          : endAt;\r\n\r\n        // track.. values are local image time\r\n        const trackStartAt = actStartAt - actOffset < 0\r\n          ? 0\r\n          : actStartAt - actOffset;\r\n        const trackDelay = startAt - actOffset < 0\r\n          ? actOffset - startAt\r\n          : 0;\r\n        const trackEndAt = actEndAt - actOffset;\r\n\r\n        // remember for progress offset\r\n        this.animateStartAt = actStartAt;\r\n        this.animateEndAt = endAt - startAt < 0.1\r\n          ? this.props.maxDuration + actOffset\r\n          : trackEndAt + actOffset;\r\n\r\n        // only play if there is something to play and only for audio (for now)\r\n        if (trackEndAt > 0 && this.playout) {\r\n          console.log(`playing ${this.props.type} from ${trackStartAt}s( ${actStartAt}s) ` +\r\n            `to ${trackEndAt}(${actEndAt}s) with delay ${trackDelay}, offset: ${actOffset}, ` +\r\n            `delay ${trackDelay}`);\r\n\r\n          this\r\n            .playout\r\n            .setUpSource()\r\n            .then(this.stopPlay); // stop when end has reached\r\n\r\n          const duration = actEndAt - actStartAt;\r\n          this\r\n            .playout\r\n            .play(this.audioContext.currentTime + trackDelay, trackStartAt, duration);\r\n        } else {\r\n          // console.log(`skip  ${this.props.type} playing from ${actStartAt}s to\r\n          // ${actEndAt}`);\r\n        }\r\n\r\n        // start progress animation\r\n        this.animationRequest = window.requestAnimationFrame(this.animateProgress);\r\n      }\r\n    }\r\n\r\n    animateProgress = (timestamp) => {\r\n\r\n      if (!this.animationStartTime) {\r\n        this.animationStartTime = timestamp;\r\n        //TODO: sync with playout time\r\n      }\r\n\r\n      const duration = timestamp - this.animationStartTime;\r\n      const currentTimeInSecs = this.animateStartAt + duration / 1000.0;\r\n\r\n      this.setState({\r\n        ...this.state,\r\n        progress: currentTimeInSecs\r\n      });\r\n\r\n      if (this.props.reportProgress) {\r\n        this\r\n          .props\r\n          .reportProgress(currentTimeInSecs);\r\n      }\r\n\r\n      if (currentTimeInSecs < this.animateEndAt) {\r\n        this.animationRequest = window.requestAnimationFrame(this.animateProgress);\r\n      } else {\r\n        this.stopPlay();\r\n      }\r\n    }\r\n\r\n    stopAnimateProgress = () => {\r\n      window.cancelAnimationFrame(this.animationRequest);\r\n      this.setState({\r\n        ...this.state,\r\n        progress: null\r\n      });\r\n      this.animationStartTime = null;\r\n    }\r\n\r\n    isPlaying = () => {\r\n      return this.animationStartTime !== null;\r\n    }\r\n\r\n    stopPlay = () => {\r\n      this.playout && this\r\n        .playout\r\n        .stop();\r\n      this.stopAnimateProgress();\r\n      this\r\n        .props\r\n        .stopChannel(this.props.channelId);\r\n    }\r\n\r\n    render() {\r\n\r\n      // time to pixel conversion is done in HOC TimeToPixel\r\n      return (<WrappedComponent {... this.props} progress={this.state.progress} />);\r\n    }\r\n  }\r\n  ;\r\n\r\n  WithPlay.propTypes = {\r\n    channelId: PropTypes.string.isRequired,\r\n    type: PropTypes.oneOf([\"audio\", \"image\", \"animation\"]),\r\n    offset: PropTypes.number,\r\n    buffer: PropTypes.object,\r\n    sampleRate: PropTypes.number.isRequired,\r\n    resolution: PropTypes.number.isRequired,\r\n    playState: PropTypes\r\n      .oneOf([\"stopped\", \"playing\"])\r\n      .isRequired,\r\n    reportProgress: PropTypes.func,\r\n    selection: PropTypes.exact({\r\n      from: PropTypes.number,\r\n      to: PropTypes.number,\r\n      type: PropTypes.string\r\n    }),\r\n    stopChannel: PropTypes.func.isRequired,\r\n    maxDuration: PropTypes.number\r\n  };\r\n\r\n  withPlay.displayName = `WithPlay(${getDisplayName(WrappedComponent)})`;\r\n  return WithPlay;\r\n}\r\n\r\nfunction getDisplayName(WrappedComponent) {\r\n  return WrappedComponent.displayName || WrappedComponent.name || \"Component\";\r\n}","import React, { Component } from \"react\";\nimport { connect } from \"react-redux\";\nimport PropTypes from \"prop-types\";\nimport memoize from \"memoize-one\";\nimport extractPeaks from \"webaudio-peaks\";\n\nimport Channel from \"./Channel\";\n\nimport { getChannelData } from \"../reducers/channelReducer\";\nimport { getParts } from \"../reducers/partReducer\";\nimport { withPlay } from \"./withPlay\";\nimport { timeToPixels } from \"./timeToPixels\";\nimport { stopChannel, } from \"../actions/channelActions\";\n\n// add play functionality to channels\nconst ChannelWithPlay = withPlay(timeToPixels(Channel));\n\nclass ChannelContainer extends Component {\n\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      error: null\n    };\n  }\n\n  componentDidCatch(error, state) {\n    this.setState({\n      error\n    });\n  }\n\n  // only re-calc when buffer, resolution of bits change\n  doExtractPeaks = memoize(\n    (buffer, pixPerSample, bits) => extractPeaks(buffer, pixPerSample, true, 0, buffer.length, bits));\n\n\n  render() {\n\n    if (this.state.error) {\n      return (\n        <div>\n          <p> ERROR! Cannot continue. </p>\n          { this.state.error.message ?\n            <p>\n              {this.state.error.message}\n            </p> : null}\n          { this.state.error.stack ?\n            <p>\n              {this.state.error.stack}\n            </p> : null}\n        </div>\n      );\n    }\n\n    const { buffer, sampleRate, resolution } = this.props;\n\n    // memoized audio peak data\n    const { data, duration, bits } = buffer ?\n      this.doExtractPeaks(buffer, sampleRate / resolution, 16)\n      : {\n        data: [],\n        length: 0,\n        bits: 0\n      };\n    const peaks = Array.isArray(data) ? data[0] : []; // only one channel for now\n\n    const renderProps = {\n      ...this.props,\n      peaks,\n      bits,\n      duration,\n    };\n\n    return (\n      <ChannelWithPlay {...renderProps} />);\n  }\n}\n\nconst mapStateToProps = (state, props) => {\n  const { channelId, images } = props;\n\n  const channelData = getChannelData(state, channelId);\n  const parts = getParts(state, channelData.parts);\n\n  return {\n    ...channelData,\n    parts,\n    images,\n  };\n};\n\nconst mapDispatchToProps = dispatch => ({\n  stopChannel: (channelId) => dispatch(stopChannel(channelId)),\n});\n\nChannelContainer.propTypes = {\n  channelId: PropTypes.string.isRequired,\n  type: PropTypes.string.isRequired,\n  loading: PropTypes.bool,\n  stopChannel: PropTypes.func.isRequired,\n  buffer: PropTypes.object,\n  sampleRate: PropTypes.number.isRequired,\n  resolution: PropTypes.number.isRequired,\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(ChannelContainer);\n","import React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\nimport styled from \"styled-components\";\n\nimport { CircularProgress } from \"@material-ui/core\";\nimport TimeScale from \"./TimeScale\";\nimport { timeToPixels } from \"./timeToPixels\";\nimport { secondsToPixels } from \"../utils/conversions\";\nimport ChannelContainer from \"./ChannelContainer\";\n\nconst ChannelGroupWrapper = styled.div`\n  width:  calc(95vw - ${props => props.drawerWidth}px);\n  transition: width .1s;\n\toverflow: auto;\n\twhite-space: nowrap;\n`;\n\nconst LoadProgressView = styled(CircularProgress)`\n  margin: 20px;\n  width: 100%;\n`;\n\n// add time conversion functionality time scale\nconst TimeScaleInSecs = timeToPixels(TimeScale);\n\n// contains multiple Channels\nexport default class ChannelGroup extends Component {\n  constructor(props) {\n    super(props);\n    this.groupRef = null;\n    this.state = {\n      scrollLeft: 0,\n    };\n  }\n\n  componentDidUpdate() {\n    this.considerScroll();\n  }\n\n  considerScroll = () => {\n    if (this.props.playState === \"playing\" && this.groupRef) {\n      const scrolldiff = Math.abs(this.state.scrollLeft - this.groupRef.scrollLeft);\n      if (scrolldiff > 10) { // do it only once for all channels\n        this.groupRef.scrollLeft = this.state.scrollLeft;\n      }\n    }\n  }\n\n  reportProgress = (progress) => {\n    // check progress to do autoscrolling \n    const progressPx = secondsToPixels(progress, this.props.resolution);\n    if (progressPx > this.groupRef.scrollLeft + this.groupRef.clientWidth) {\n      this.setState({ scrollLeft: progressPx });\n    } else if (progressPx < this.groupRef.scrollLeft) {\n      this.setState({ scrollLeft: progressPx });\n    }\n  }\n\n  render() {\n\n    const { allchannelIds, ...passthruProps } = this.props;\n\n    const channelComponents = allchannelIds\n      .map((channelId) => (\n\n        <ChannelContainer {...passthruProps}\n          className=\"ChannelContainer\"\n          channelId={channelId}\n          key={channelId}\n          reportProgress={this.reportProgress}\n        />));\n\n    return (\n      <ChannelGroupWrapper\n        className=\"ChannelGroupWrapper\"\n        drawerWidth={this.props.drawerWidth || 0}\n        ref={(ref) => this.groupRef = ref}>\n\n        <TimeScaleInSecs\n          className=\"TimeScaleInSecs\"\n          maxDuration={this.props.maxDuration}\n          resolution={this.props.resolution}\n          theme={this.props.theme}\n        />\n\n        {channelComponents}\n\n        {this.props.isLoadingShow &&\n          <LoadProgressView disableShrink />\n        }\n\n      </ChannelGroupWrapper>\n    );\n  }\n}\n\nChannelGroup.propTypes = {\n  allchannelIds: PropTypes.array,\n  resolution: PropTypes.number.isRequired,\n  drawerWidth: PropTypes.number.isRequired,\n  selectedImageChannelId: PropTypes.number,\n  playState: PropTypes.string,\n  maxDuration: PropTypes.number,\n  isLoadingShow: PropTypes.bool,\n  theme: PropTypes.object.isRequired,\n};","export const defaultTheme = {\n  // color of the waveform outline\n  waveOutlineColor: \"#282c34\",\n  waveFillColor: \"#05a0cd\",\n  waveProgressColor: \"transparent\", //'rgb(255,120,0)',\n  waveProgressBorderColor: \"rgb(255,255,255)\",\n\n  markerColor: \"rgba(255,255, 0, 0.5)\", // transparent yellow\n  markerColorOther: \"rgba(255,255, 0, 0.2)\", // more transparent yellow\n  insertMarkerColor: \"rgba(255,165, 0, 0.5)\", // transparent orange\n  selectedMarkerColor: \"rgba(255,165, 0, 1)\", // orange\n  selectedMarkerColorOther: \"rgba(255,165, 0, 0.3)\", // orange slightly transp\n  selectionColor: \"rgba(200,200,255,0.5)\",\n  tempSelectionColor: \"rgba(80,80,80,0.5)\",\n\n  imageBackgroundColor: \"black\",\n  imageBackgroundColorSelected: \"#101010\",\n  borderColor: \"#3f51b5\",\n\n  timeColor: \"grey\", // color of the time ticks on the canvas\n};","import React, { Component } from \"react\";\nimport { connect } from \"react-redux\";\n\nimport ChannelGroup from \"./ChannelGroup\";\nimport { setMessage } from \"../actions/viewActions\";\nimport { getSelectionRange, getResolution, isLoadingShow } from \"../reducers/viewReducer\";\nimport { getImages } from \"../reducers/imageListReducer\";\nimport { getMaxChannelDuration, getAllChannelIds, allChannelsStopped } from \"../reducers/channelReducer\";\nimport { defaultTheme } from \"./themes\";\n\nclass ChannelGroupContainer extends Component {\n\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      error: null\n    };\n  }\n\n  componentDidCatch(error, state) {\n    this.setState({\n      error\n    });\n  }\n\n  render() {\n\n    if (this.state.error) {\n      return (\n        <div>\n          <p> ERROR! Cannot continue. </p>\n          {this.state.error.message ? <p>\n            {this.state.error.message} </p> : null}\n          {this.state.error.stack ? <p>\n            {this.state.error.stack} </p> : null}\n        </div>\n      );\n    }\n\n\n    const renderProps = {\n      ...this.props,\n      theme: defaultTheme\n    };\n\n    return (\n      <ChannelGroup { ...renderProps } />\n    );\n  }\n}\n\nconst mapStateToProps = (state, props) => {\n  return {\n    allchannelIds: getAllChannelIds(state),\n    maxDuration: getMaxChannelDuration(state),\n    images: getImages(state),\n    playState: allChannelsStopped(state) ? \"stopped\" : \"playing\", // for HOC withPlay only\n    isLoadingShow: isLoadingShow(state),\n    resolution: getResolution(state),\n\n    selection: getSelectionRange(state),\n  };\n};\n\nconst mapDispatchToProps = dispatch => ({\n  setMessage: (text, type, title) => dispatch(setMessage({ text, type, title })),\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(ChannelGroupContainer);\n","import React, { PureComponent } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport styled from \"styled-components\";\r\n\r\nconst ImageExporterWrapper = styled.div`\r\n\twidth:  calc(95vw - ${props => props.drawerWidth}px);\r\n\toverflow: auto;\r\n`;\r\n\r\nconst ImageExporterCanvas = styled.canvas`\r\n\toverflow: auto;\r\n\tflex-wrap: wrap;\r\n`;\r\n\r\nexport default class ImageExporter extends PureComponent {\r\n\tconstructor(props) {\r\n\t\tsuper(props);\r\n\t\tthis.state = {\r\n\t\t\tdragging: false\r\n\t\t};\r\n\t}\r\n\r\n\r\n\trender() {\r\n\r\n\t\treturn (\r\n\t\t\t<ImageExporterWrapper drawerWidth={ this.props.drawerWidth }>\r\n\t\t\t\t<ImageExporterCanvas id=\"imageExportCanvas\" />\r\n\t\t\t</ImageExporterWrapper>\r\n\t\t);\r\n\t}\r\n}\r\n\r\nImageExporter.propTypes = {\r\n\tdrawerWidth: PropTypes.number,\r\n};","import React, { PureComponent } from \"react\";\nimport PropTypes from \"prop-types\";\nimport styled from \"styled-components\";\nimport { getChannelExportData } from \"../actions/ioActions\";\nimport { samplesToRad } from \"../utils/conversions\";\nimport { Typography, Slider } from \"@material-ui/core\";\n\nconst minRotationSpeed = 0.1;\nconst maxRotationSpeed = 9.9;\n\nconst WhiteSlider = styled(Slider)`\n  .MuiSlider-track {\n    background-color: white;\n  }\n  .MuiSlider-thumbWrapper {\n    button {\n      background-color: white;\n    }\n  }\n`;\n\nconst AnimationPaneWrapper = styled.div`\n\twidth:  calc(95vw - ${props => props.drawerWidth}px);\n\tbackground-color: black;\n\tdisplay: flex;\n\tflex-direction: row;\n`;\n\nconst AnimationControl = styled.div`\n\twidth:  96px;\n\tbackground-color: #2c387e;\n\tdisplay: flex;\n\tflex-direction: row;\n\tjustify-content: space-around;\n\talign-items: flex-end;\n\tpadding: 20px;\n\tcolor: #3f51b5;\n\tfont-weight: 600;\n`;\n\nconst RotationSpeed = styled(Typography)`\n\tcolor: white\n`;\n\nconst AnimationCanvas = styled.canvas`\n`;\n\nexport default class AnimationPane extends PureComponent {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.prevRad = 0;\n\t\tthis.prevTime = 0;\n\t\tthis.innerRadius = 2;\n\t\tthis.margin = 10;\n\t\tthis.state = {\n\t\t\trotationSpeed: 2, // rotations per second\n\t\t};\n\t}\n\n\tcomponentDidMount() {\n\t\tthis.draw();\n\t}\n\n\tcomponentDidUpdate(prevProps) {\n\t\tconst initiallyBlack = this.props.progress && !prevProps.progress;\n\t\tthis.draw(initiallyBlack);\n\t}\n\n\tdrawArc(cc, arcIdx, color, radius, fromRad, toRad) {\n\n\t\tconst { resolution } = this.props;\n\n\t\tconst largestRadius = resolution * (30 + this.innerRadius);\n\t\tconst centerX = this.margin + largestRadius + arcIdx * (this.margin + 2 * largestRadius);\n\t\tconst centerY = this.margin + largestRadius;\n\n\t\tcc.beginPath();\n\t\tcc.arc(centerX, centerY, resolution * radius, fromRad, toRad, false);\n\t\tcc.strokeStyle = color;\n\t\tcc.lineWidth = 2;\n\t\tcc.stroke();\n\t}\n\n\tdraw(initiallyBlack = false) {\n\n\t\tconst { progress, sampleRate, activeChannels } = this.props;\n\n\t\tif (progress && progress > 0) {\n\t\t\t// get the part of the image that happened during the last update interval\n\t\t\tconst expData = getChannelExportData(this.prevTime, progress, sampleRate);\n\n\t\t\tconst canvas = document.getElementById(\"animationPaneCanvas\");\n\t\t\t// canvas.height = 2* (2*this.innerRadius + 60) + 20;\n\n\t\t\tconst cc = canvas.getContext(\"2d\");\n\t\t\tif (initiallyBlack) {\n\t\t\t\tcc.fillStyle = \"black\";\n\t\t\t\tcc.fillRect(0, 0, canvas.width, canvas.height);\n\t\t\t}\n\n\t\t\tconst oneSampleRad = samplesToRad(1, sampleRate, this.state.rotationSpeed);\n\t\t\tconst d = expData.data;\n\t\t\tconst numArcs = activeChannels.length;\n\n\t\t\t// console.log(`Num arcs: ${numArcs} (${expData.height} x ${expData.width})`)\n\n\t\t\tfor (let w = 0; w < expData.width; w++) { //left to right (i.e. time)\n\t\t\t\tconst toRad = this.prevRad + oneSampleRad;\n\t\t\t\tfor (let i = 0; i < 30; i++) { // top to bottom\n\t\t\t\t\tfor (let arcIdx = 0; arcIdx < numArcs; arcIdx++) { // pois\n\t\t\t\t\t\tconst row = 30 * arcIdx + i;\n\t\t\t\t\t\tconst startIdx = row * expData.width + w;\n\t\t\t\t\t\t// console.log(`animate: ${row} ${startIdx}`)\n\t\t\t\t\t\tconst dataIdx = 4 * startIdx;\n\t\t\t\t\t\tconst color = `rgba(${d[dataIdx]},${d[dataIdx + 1]},${d[dataIdx + 2]},255)`;\n\t\t\t\t\t\tthis.drawArc(cc, arcIdx, color, i + this.innerRadius, this.prevRad, toRad);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.prevRad = toRad;\n\t\t\t}\n\t\t\tthis.prevTime = progress;\n\t\t}\n\t}\n\n\n\tspeed2slider(speed) {\n\t\treturn (speed - minRotationSpeed) / (maxRotationSpeed - minRotationSpeed) * 100;\n\t}\n\n\tslider2speed(val) {\n\t\t//100 -> max, 0 -> min\n\t\treturn minRotationSpeed + val / 100 * (maxRotationSpeed - minRotationSpeed);\n\t}\n\n\thandleChange = (ev, val) => {\n\t\tconst rotationSpeed = this.slider2speed(val);\n\t\tthis.setState({\n\t\t\trotationSpeed\n\t\t});\n\t};\n\n\trender() {\n\n\t\tconst { rotationSpeed } = this.state;\n\n\t\tconst { drawerWidth, activeChannels, resolution } = this.props;\n\t\treturn (\n\t\t\t<AnimationPaneWrapper drawerWidth={ drawerWidth }>\n\t\t\t\t<AnimationControl>\n\t\t\t\t\t<RotationSpeed>\t{rotationSpeed.toFixed(1)}</RotationSpeed>\n\n\t\t\t\t\t<WhiteSlider value={ this.speed2slider(rotationSpeed) }\n\t\t\t\t\t\tonChange={ this.handleChange }\n\t\t\t\t\t\torientation=\"vertical\"\n\t\t\t\t\t\tstyle={ { width: 0 } } />\n\t\t\t\t</AnimationControl>\n\t\t\t\t<AnimationCanvas\n\t\t\t\t\tid=\"animationPaneCanvas\"\n\t\t\t\t\theight={ resolution * 80 }\n\t\t\t\t\twidth={ activeChannels.length * resolution * 80 } />\n\t\t\t</AnimationPaneWrapper>\n\n\t\t);\n\t}\n}\n\nAnimationPane.propTypes = {\n\tprogress: PropTypes.number,\n\tsampleRate: PropTypes.number.isRequired,\n\tresolution: PropTypes.number.isRequired,\n\tactiveChannels: PropTypes.arrayOf(PropTypes.string),\n\tdrawerWidth: PropTypes.number,\n};","import React, { Component } from \"react\";\r\nimport { connect } from \"react-redux\";\r\n\r\nimport AnimationPane from \"./AnimationPane\";\r\nimport { getSelectionRange } from \"../reducers/viewReducer\";\r\nimport { getActiveChannelIds, allChannelsStopped, getMaxChannelDuration } from \"../reducers/channelReducer\";\r\nimport { withPlay } from \"./withPlay\";\r\n\r\nconst AnimationPaneWithPlay = withPlay(AnimationPane);\r\n\r\nclass AnimationPaneContainer extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.playState = \"stopped\";\r\n  }\r\n\r\n  stopChannel(channelId) {\r\n    // empty for now, but required for WithPlay\r\n  }\r\n\r\n  render() {\r\n\r\n    return (\r\n      <AnimationPaneWithPlay sampleRate={100} resolution={2}\r\n        type=\"animation\" stopChannel={this.stopChannel}\r\n        channelId=\"none\" {...this.props}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nconst mapStateToProps = state => ({\r\n  playState: allChannelsStopped(state) ? \"stopped\" : \"playing\",\r\n  activeChannels: getActiveChannelIds(state, \"image\"),\r\n  selection: getSelectionRange(state),\r\n  maxDuration: getMaxChannelDuration(state),\r\n});\r\n\r\nconst mapDispatchToProps = dispatch => ({\r\n  //  no actions needed\r\n});\r\n\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(AnimationPaneContainer);\r\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport classNames from \"classnames\";\nimport styled from \"styled-components\";\nimport isElectron from \"is-electron\";\n\nimport { withStyles } from \"@material-ui/core/styles\";\nimport { Tooltip, IconButton, Slider } from \"@material-ui/core\";\nimport { indigo } from \"@material-ui/core/colors/indigo\";\n\nimport {\n  SaveAlt as DownloadChannelIcon,\n  DeleteForever as DeleteChannelIcon,\n} from \"@material-ui/icons\";\nimport {\n  LighthouseOn as UploadImageChannelToPoiIcon,\n  ContentDuplicate as ChannelDupIcon\n} from \"mdi-material-ui\";\n\nconst WhiteSlider = styled(Slider)`\n  .MuiSlider-track {\n    background-color: white;\n  }\n  .MuiSlider-thumbWrapper {\n    button {\n      background-color: white;\n    }\n  }\n`;\n\nconst channelSelectorWidth = 96;\n\nconst styles = () => ({\n  channelSelectorWrapper: {\n    display: \"flex\",\n    justifyContent: \"space-between\",\n    flexDirection: \"row\",\n    padding: \"12px\",\n    height: \"92px\",\n    width: `${channelSelectorWidth}px`,\n    border: \"1px #3949ab solid\",\n    borderRight: \"none\",\n  },\n  wrapperInActive: {\n    background: \"#212121\",\n  },\n  wrapperSelected: {\n    backgroundColor: \"#3f51b5\",\n  },\n  sliderWrapper: {\n    display: \"flex\",\n    justifyContent: \"flex-end\",\n    padding: \"4px\",\n  },\n  icon: {\n    fill: \"white\",\n    width: \".8em\"\n  },\n  button: {\n    padding: 0,\n    margin: 0,\n  },\n  button1: {\n    paddingRight: \"8px\",\n  },\n  actionsWrapper: {\n    width: \"100%\",\n    paddingRight: \"8px\",\n    display: \"flex\",\n    flexDirection: \"column\",\n    justifyContent: \"flex-end\",\n  },\n  actionsRow: {\n    display: \"flex\",\n    flexDirection: \"row\",\n    justifyContent: \"flex-end\",\n  },\n  actionsRow2: {\n    padding: \"8px 0 2px 0\",\n  },\n});\n\nfunction ChannelSelector(props) {\n\n  const handleChange = (channelId, active) => (event, val) => {\n    props.updateChannel({\n      channelId,\n      gain: val\n    });\n    if (val === 0 && active) {\n      props.setChannelInactive(channelId);\n    } else if (val > 0 && !active) {\n      props.setChannelActive(channelId);\n    }\n  };\n\n  const { classes, channelId, selected, active, gain, type } = props;\n  const electronVersion = isElectron();\n  const isImageChannel = type === \"image\";\n\n  return (\n    <div key={ channelId }\n      className={ classNames(\n        classes.channelSelectorWrapper,\n        selected && active && classes.wrapperSelected,\n        !active && classes.wrapperInActive)\n      }\n      background={ indigo }>\n\n      <div className={ classes.actionsWrapper }>\n        <div className={ classes.actionsRow }>\n          {isImageChannel && <Tooltip title=\"Upload channel to poi\">\n            <IconButton\n              className={ classNames(classes.button, classes.button1) }\n              disabled={ !electronVersion }\n              onClick={ () => props.uploadImageChannelToPoi(channelId) }>\n              <UploadImageChannelToPoiIcon className={ classes.icon } />\n            </IconButton>\n          </Tooltip>}\n          {isImageChannel && <Tooltip title={ \"Save channel as binary\" }>\n            <IconButton\n              className={ classes.button }\n              onClick={ () => props.saveImageChannelAsBinary(channelId) }>\n              <DownloadChannelIcon className={ classes.icon } />\n            </IconButton>\n          </Tooltip>}\n        </div>\n\n        <div className={ classNames(classes.actionsRow, classes.actionsRow2) }>\n          {isImageChannel && <Tooltip title=\"Duplicate channel\">\n            <IconButton\n              className={ classNames(classes.button, classes.button1) }\n              onClick={ () => props.duplicateChannel(channelId) }>\n              <ChannelDupIcon className={ classes.icon } />\n            </IconButton>\n          </Tooltip>}\n\n          <Tooltip title=\"Delete channel\">\n            <IconButton\n              className={ classes.button }\n              onClick={ () => props.deleteChannel(channelId) }>\n              <DeleteChannelIcon className={ classes.icon } />\n            </IconButton>\n          </Tooltip>\n        </div>\n      </div>\n      <div className={ classes.sliderWrapper }>\n        <Tooltip title={ gain === 0 ? \"channel off\" : `gain: ${gain.toPrecision(2)}` }>\n          <WhiteSlider \n            orientation=\"vertical\"\n            className={ classes.slider }\n            value={ gain }\n            onChange={ handleChange(channelId, active) }\n            min={ 0 }\n            max={ 1 }\n            step={ 0.05 } />\n        </Tooltip>\n      </div>\n\n    </div>);\n\n}\n\nChannelSelector.propTypes = {\n  classes: PropTypes.object.isRequired,\n  channelId: PropTypes.string.isRequired,\n  type: PropTypes.oneOf([\"image\", \"audio\"]).isRequired,\n  selected: PropTypes.bool,\n  active: PropTypes.bool,\n  gain: PropTypes.number,\n  setChannelActive: PropTypes.func.isRequired,\n  setChannelInactive: PropTypes.func.isRequired,\n  updateChannel: PropTypes.func.isRequired,\n  duplicateChannel: PropTypes.func.isRequired,\n  deleteChannel: PropTypes.func.isRequired,\n  uploadImageChannelToPoi: PropTypes.func.isRequired,\n  saveImageChannelAsBinary: PropTypes.func.isRequired,\n};\n\nexport default withStyles(styles)(ChannelSelector);","import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport { withStyles } from \"@material-ui/core/styles\";\nimport { Tooltip, IconButton } from \"@material-ui/core\";\n\nimport {\n  Magnet as SnapIcon,\n} from \"mdi-material-ui\";\n\nconst channelSelectorWidth = 96;\n\nconst styles = () => ({\n  snapWrapper: {\n    height: \"30px\",\n    width: `${channelSelectorWidth}px`,\n    display: \"flex\",\n    flexDirection: \"row\",\n    justifyContent: \"flex-start\",\n    alignItems: \"center\",\n    border: \"1px #3949ab solid\",\n    borderRight: \"none\",\n  },\n  snapButton: {\n    color: props => props.snapToMarkers ? \"red\" : \"white\",\n  },\n  snapIcon: {\n    width: \".6em\"\n  },\n  checked: {} // default checkbox style\n});\n\nfunction TimeScaleSelector(props) {\n\n  const { classes, snapToMarkers } = props;\n  const tooltipText = `Snap to markers: ${snapToMarkers ? \"on\" : \"off\"}`;\n\n  return (\n    <div\n      className={ classes.snapWrapper }>\n      <Tooltip title={ tooltipText }>\n        <IconButton\n          props={ { snapToMarkers } }\n          className={ classes.snapButton }\n          onClick={ props.toggleSnapToMarkers }>\n          <SnapIcon\n            className={ classes.snapIcon } />\n        </IconButton>\n\n      </Tooltip>\n    </div >\n\n  );\n};\n\nTimeScaleSelector.propTypes = {\n  classes: PropTypes.object.isRequired,\n  snapToMarkers: PropTypes.bool.isRequired,\n  toggleSnapToMarkers: PropTypes.func.isRequired,\n};\n\nexport default withStyles(styles)(TimeScaleSelector);","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { withStyles } from \"@material-ui/core/styles\";\nimport FormGroup from \"@material-ui/core/FormGroup\";\nimport ChannelSelector from \"./ChannelSelector\";\nimport TimeScaleSelector from \"./TimeScaleSelector\";\n\nconst styles = () => ({\n  formGroup: {\n    background: \"#2c387e\",\n  },\n});\n\nfunction ChannelSelectorGroup(props) {\n\n  const { classes, channelIds, ...passthruProps } = props;\n\n  const channelSelectors = props.channelIds\n    .map((channelId) => {\n\n      const channelInfo = {\n        ...passthruProps,\n        ...props.getChannelSelectorData(channelId),\n        key: channelId,\n      };\n\n      return (<ChannelSelector { ...channelInfo } />);\n    });\n\n\n  return (\n    <FormGroup className={ classes.formGroup }>\n      {props.channelIds && props.channelIds.length > 0 &&\n        <TimeScaleSelector\n          snapToMarkers={ props.snapToMarkers }\n          toggleSnapToMarkers={ props.toggleSnapToMarkers } />\n      }\n      {channelSelectors}\n    </FormGroup>\n  );\n}\n\nChannelSelectorGroup.propTypes = {\n  classes: PropTypes.object.isRequired,\n  channelIds: PropTypes.array,\n  getChannelSelectorData: PropTypes.func.isRequired,\n  snapToMarkers: PropTypes.bool.isRequired,\n  toggleSnapToMarkers: PropTypes.func.isRequired,\n};\n\nexport default withStyles(styles)(ChannelSelectorGroup);","import React, { Component } from \"react\";\nimport { connect } from \"react-redux\";\n\nimport ChannelSelectorGroup from \"./ChannelSelectorGroup\";\nimport { updateChannel, setChannelActive, setChannelInactive, deleteChannel, duplicateChannel } from \"../actions/channelActions\";\nimport { uploadImageChannelToPoi, saveImageChannelAsBinary } from \"../actions/ioActions\";\n\nimport { getChannelSelectorData, getAllChannelIds } from \"../reducers/channelReducer\";\nimport { toggleSnapToMarkers } from \"../actions/viewActions\";\nimport { getSnapToMarkers } from \"../reducers/viewReducer\";\n\nclass ChannelSelectorGroupContainer extends Component {\n\n  render() {\n    return (\n      <ChannelSelectorGroup { ...this.props } />\n    );\n  };\n\n}\n\nconst mapStateToProps = (state, props) => {\n  return {\n    channelIds: getAllChannelIds(state),\n    snapToMarkers: getSnapToMarkers(state),\n    getChannelSelectorData: (channelId) => getChannelSelectorData(state, channelId),\n  };\n};\n\nconst mapDispatchToProps = dispatch => ({\n  updateChannel: (channelInfo) => dispatch(updateChannel(channelInfo)),\n  setChannelActive: (channelId) => dispatch(setChannelActive(channelId)),\n  setChannelInactive: (channelId) => dispatch(setChannelInactive(channelId)),\n  uploadImageChannelToPoi: (channelId) => dispatch(uploadImageChannelToPoi(channelId)),\n  saveImageChannelAsBinary: (channelId) => dispatch(saveImageChannelAsBinary(channelId)),\n  deleteChannel: (channelId) => dispatch(deleteChannel(channelId)),\n  duplicateChannel: (channelId) => dispatch(duplicateChannel(channelId)),\n  toggleSnapToMarkers: (val) => dispatch(toggleSnapToMarkers()),\n});\n\nChannelSelectorGroupContainer.propTypes = {\n  /* no props being used here */\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(ChannelSelectorGroupContainer);\n","import React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { connect } from \"react-redux\";\n\nimport { getUploadLog } from \"../reducers/viewReducer\";\nimport UploadLogView from \"./UploadLogView\";\nimport { clearUploadLog } from \"../actions/viewActions\";\nimport { cancelUpload } from \"../actions/ioActions\";\n\nclass ImageControlContainer extends Component {\n  render() {\n    return (<UploadLogView { ...this.props } />);\n  }\n}\n\nconst mapStateToProps = (state, props) => {\n  return {\n    uploadLog: getUploadLog(state),\n  };\n};\n\nconst mapDispatchToProps = dispatch => ({\n  clearUploadLog: () => dispatch(clearUploadLog()),\n  cancelUpload: () => dispatch(cancelUpload()),\n});\n\nImageControlContainer.propTypes = {\n  uploadLog: PropTypes.string,\n  clearUploadLog: PropTypes.func.isRequired,\n  cancelUpload: PropTypes.func.isRequired,\n};\n\n\nexport default connect(mapStateToProps, mapDispatchToProps)(ImageControlContainer);\n","import React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { withStyles } from \"@material-ui/core/styles\";\nimport { Modal, Typography, Button } from \"@material-ui/core\";\n\nconst styles = theme => ({\n  paper: {\n    position: \"absolute\",\n    backgroundColor: theme.palette.background.paper,\n    boxShadow: theme.shadows[5],\n    padding: theme.spacing(4),\n    outline: \"none\",\n    top: \"20%\",\n    left: \"20%\",\n    display: \"flex\",\n    flexDirection: \"column\"\n  },\n  headingArea: {\n    display: \"flex\",\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    marginBottom: theme.spacing(2),\n  },\n  textArea: {\n    marginBottom: theme.spacing(2),\n    height: \"100%\",\n    overflow: \"auto\",\n  },\n  text: {\n    fontSize: \"14px\",\n    lineHeight: \"normal\",\n    wordBreak: \"break-all\",\n  },\n  buttonArea: {\n    alignSelf: \"flex-end\",\n  }\n});\n\n\nexport class MessageView extends Component {\n\n  handleClose = () => {\n    return this.props.clearMessage();\n  }\n\n\n  render() {\n\n    const { message, classes } = this.props;\n\n    const messageTitle = (message && message.title) ? \n      message.title : \"Message\";\n\n    const messageHtml = (message && message.text) ? (\n      <Typography className={ classes.text }>\n        { message.text }\n      </Typography>) : null;  \n\n    return (\n      <Modal open={ Boolean(message) }\n          aria-labelledby=\"simple-modal-title\"\n          aria-describedby=\"simple-modal-description\"\n          disableBackdropClick={ true }\n          onClose={ this.handleClose }>\n        <div className={ classes.paper }>\n          <div  className={ classes.headingArea }>\n          <Typography variant=\"h6\"\n              id=\"modal-title\">\n            { messageTitle }\n          </Typography>\n\n          </div>\n          <div className={ classes.textArea }>\n            <div variant=\"body2\"\n                id=\"simple-modal-description\">\n              { messageHtml }\n            </div>\n          </div>\n          <div className={ classes.buttonArea }>\n            <Button \n                onClick={ this.handleClose }>OK</Button>\n          </div>\n        </div>\n      </Modal>\n      );\n  }\n}\n\nMessageView.propTypes = {\n  classes: PropTypes.object.isRequired,\n  theme: PropTypes.object.isRequired,\n  message: PropTypes.objectOf({\n    text: PropTypes.string,\n    type: PropTypes.string,\n    title: PropTypes.string,\n  }),\n  clearMessage: PropTypes.func.isRequired,\n};\n\nexport default withStyles(styles, {\n  withTheme: true\n})(MessageView);\n","import React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { connect } from \"react-redux\";\n\nimport { clearMessage } from \"../actions/viewActions\";\nimport { getMessage } from \"../reducers/viewReducer\";\nimport MessageView from \"./MessageView\";\n\nclass MessageViewContainer extends Component {\n\n  render() {\n    return ( <MessageView { ...this.props } /> );\n  }\n}\n\nconst mapStateToProps = (state, props) => {\n  return {\n    message: getMessage(state),\n  };\n};\n\nconst mapDispatchToProps = dispatch => ({\n  clearMessage: () => dispatch(clearMessage()),\n});\n\nMessageViewContainer.propTypes = {\n  message: PropTypes.object,\n  clearMessage: PropTypes.func.isRequired,\n};\n\n\nexport default connect(mapStateToProps, mapDispatchToProps)(MessageViewContainer);\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport classNames from \"classnames\";\nimport { withStyles } from \"@material-ui/core/styles\";\nimport Drawer from \"@material-ui/core/Drawer\";\nimport AppBar from \"@material-ui/core/AppBar\";\nimport Toolbar from \"@material-ui/core/Toolbar\";\nimport CssBaseline from \"@material-ui/core/CssBaseline\";\nimport Typography from \"@material-ui/core/Typography\";\nimport Divider from \"@material-ui/core/Divider\";\nimport IconButton from \"@material-ui/core/IconButton\";\nimport BurstModeIcon from \"@material-ui/icons/BurstMode\";\nimport ChevronLeftIcon from \"@material-ui/icons/ChevronLeft\";\nimport ChevronRightIcon from \"@material-ui/icons/ChevronRight\";\n\nimport HeaderContainer from \"./components/HeaderContainer\";\nimport ImageControlContainer from \"./components/ImageControlContainer\";\nimport ImageListContainer from \"./components/ImageListContainer\";\nimport ChannelGroupContainer from \"./components/ChannelGroupContainer\";\nimport { Tooltip } from \"@material-ui/core\";\nimport ImageExporter from \"./components/ImageExporter\";\nimport AnimationPaneContainer from \"./components/AnimationPaneContainer\";\nimport ChannelSelectorGroupContainer from \"./components/ChannelSelectorGroupContainer\";\nimport UploadLogViewContainer from \"./components/UploadLogViewContainer\";\nimport MessageViewContainer from \"./components/MessageViewContainer\";\n\nconst drawerWidth = 400;\nconst channelSelectorWidth = 96;\n\nconst styles = theme => ({\n  root: {\n    display: \"flex\",\n    flexGrow: 1,\n  },\n  grow: {\n    flexGrow: 1,\n  },\n  appBar: {\n    transition: theme.transitions.create([\"margin\", \"width\"], {\n      easing: theme.transitions.easing.sharp,\n      duration: theme.transitions.duration.leavingScreen,\n    }),\n  },\n  appBarShift: {\n    width: `calc(100% - ${drawerWidth}px)`,\n    transition: theme.transitions.create([\"margin\", \"width\"], {\n      easing: theme.transitions.easing.easeOut,\n      duration: theme.transitions.duration.enteringScreen,\n    }),\n    marginRight: drawerWidth,\n  },\n  title: {\n    display: \"flex\",\n    flexDirection: \"row\",\n    paddingLeft: 20,\n    minWidth: \"6em\",\n  },\n  title1: {\n    color: \"#f44336\",\n  },\n  title2: {\n    color: \"#ffc107\",\n  },\n  title3: {\n    color: \"#e91e63\",\n  },\n  title4: {\n    color: \"#8bc34a\",\n  },\n  title5: {\n    color: \"#00bcd4\",\n  },\n  title6: {\n    color: \"#8bc34a\",\n  },\n  title7: {\n    color: \"#af52bf\",\n  },\n  title8: {\n    color: \"#d7e360\",\n  },\n  title9: {\n    color: \"#ffc107\",\n  },\n  menuButton: {\n    marginLeft: 12,\n    marginRight: 20,\n  },\n  hide: {\n    display: \"none\",\n  },\n  drawer: {\n    width: drawerWidth,\n    flexShrink: 0,\n  },\n  drawerPaper: {\n    width: drawerWidth,\n  },\n  drawerHeader: {\n    display: \"flex\",\n    alignItems: \"center\",\n    padding: \"0 8px\",\n    ...theme.mixins.toolbar,\n    justifyContent: \"space-between\",\n  },\n  content: {\n    flexGrow: 1,\n    padding: theme.spacing(3),\n    transition: theme.transitions.create(\"margin\", {\n      easing: theme.transitions.easing.sharp,\n      duration: theme.transitions.duration.leavingScreen,\n    }),\n    marginRight: -drawerWidth,\n  },\n  contentShift: {\n    transition: theme.transitions.create(\"margin\", {\n      easing: theme.transitions.easing.easeOut,\n      duration: theme.transitions.duration.enteringScreen,\n    }),\n    marginRight: 0,\n  },\n  channelPane: {\n    display: \"flex\",\n    flexDirection: \"row\",\n  }\n});\n\nclass App extends React.Component {\n  static getDerivedStateFromError(error) {\n    return { error };\n  }\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      error: null,\n      open: false,\n    };\n  }\n\n  componentDidCatch(error, state) {\n    this.setState({\n      ...this.state,\n      error\n    });\n  }\n\n\n  handleDrawerOpen = () => {\n    this.setState({\n      ...this.state,\n      open: true\n    });\n  };\n\n  handleDrawerClose = () => {\n    this.setState({\n      ...this.state,\n      open: false\n    });\n  };\n\n  render() {\n\n    if (this.state.error) {\n      return (\n        <div>\n          <p> ERROR! Cannot continue. </p>\n          {this.state.error.message ? <p> {this.state.error.message} </p> : null}\n          {this.state.error.stack ? <p> {this.state.error.stack} </p> : null}\n        </div>\n      );\n    }\n\n    const { classes, theme } = this.props;\n    const { open } = this.state;\n\n    return (\n      <div className={ classes.root }>\n        <CssBaseline />\n        <AppBar position=\"fixed\"\n          className={ classNames(classes.appBar, {\n            [classes.appBarShift]: open,\n          }) }>\n          <Toolbar disableGutters={ !open }>\n            <div className={ classes.title }>\n              <Typography\n                variant=\"h6\"\n                className={ classes.title1 }>L</Typography>\n              <Typography variant=\"h6\"\n                className={ classes.title2 }>u</Typography>\n              <Typography variant=\"h6\"\n                className={ classes.title3 }>m</Typography>\n              <Typography variant=\"h6\"\n                className={ classes.title4 }>i</Typography>\n              <Typography variant=\"h6\"\n                className={ classes.title5 }>n</Typography>\n              <Typography variant=\"h6\"\n                className={ classes.title6 }>o</Typography>\n              <Typography variant=\"h6\"\n                className={ classes.title7 }>s</Typography>\n              <Typography variant=\"h6\"\n                className={ classes.title8 }>i</Typography>\n              <Typography variant=\"h6\"\n                className={ classes.title9 }>a</Typography>\n            </div>\n            <HeaderContainer />\n            <div className={ classes.grow }></div>\n            <Tooltip title=\"Work with images\">\n              <IconButton color=\"inherit\"\n                aria-label=\"Open drawer\"\n                onClick={ this.handleDrawerOpen }\n                className={ classNames(classes.menuButton, open && classes.hide) }>\n                <BurstModeIcon />\n              </IconButton>\n            </Tooltip>\n          </Toolbar>\n        </AppBar>\n        <main className={ classNames(classes.content, {\n          [classes.contentShift]: open,\n        }) }>\n          <div className={ classes.drawerHeader } />\n          <MessageViewContainer />\n          <UploadLogViewContainer />\n          <AnimationPaneContainer drawerWidth={ open ? drawerWidth : 0 } />\n          <div className={ classes.channelPane }>\n            <ChannelSelectorGroupContainer />\n            <ChannelGroupContainer drawerWidth={ open ? drawerWidth + channelSelectorWidth : channelSelectorWidth }\n              width={ channelSelectorWidth } />\n          </div>\n          <ImageExporter drawerWidth={ open ? drawerWidth : 0 } />\n        </main>\n        <Drawer className={ classes.drawer }\n          variant=\"persistent\"\n          anchor=\"right\"\n          open={ open }\n          classes={ { paper: classes.drawerPaper, } }>\n          <div className={ classes.drawerHeader }>\n            <IconButton onClick={ this.handleDrawerClose }>\n              {theme.direction === \"rtl\" ? <ChevronLeftIcon /> : <ChevronRightIcon />}\n            </IconButton>\n            <ImageControlContainer />\n          </div>\n          <Divider />\n          <ImageListContainer />\n          <Divider />\n        </Drawer>\n      </div>\n    );\n  }\n}\n\nApp.propTypes = {\n  classes: PropTypes.object.isRequired,\n  theme: PropTypes.object.isRequired,\n};\n\nexport default withStyles(styles, {\n  withTheme: true\n})(App);","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n  // [::1] is the IPv6 localhost address.\n  window.location.hostname === \"[::1]\" ||\n  // 127.0.0.1/8 is considered localhost for IPv4.\n  window.location.hostname.match(\n    /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n  )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n            \"worker. To learn more, visit http://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                \"tabs for this page are closed. See http://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get(\"content-type\").indexOf(\"javascript\") === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Provider } from \"react-redux\";\nimport configureStore from \"./store\";\n\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n    <Provider store={ configureStore() }>\n      <App />\n    </Provider>,\n    document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { withStyles } from \"@material-ui/core/styles\";\nimport { Modal, Typography, Button, CircularProgress } from \"@material-ui/core\";\n\nexport const doneMessage = \"Upload completed.\";\nexport const doneWithErrorMessage = \"Unable to complete upload.\";\nexport const doneWithCancelledMessage = \"Upload cancelled.\";\n\nconst styles = theme => ({\n  paper: {\n    position: \"absolute\",\n    backgroundColor: theme.palette.background.paper,\n    boxShadow: theme.shadows[5],\n    padding: theme.spacing(4),\n    outline: \"none\",\n    top: \"20%\",\n    left: \"20%\",\n    width: \"60%\",\n    height: \"70vh\",\n    display: \"flex\",\n    flexDirection: \"column\"\n  },\n  headingArea: {\n    display: \"flex\",\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    marginRight: \"20px\",\n    marginBottom: \"10px\",\n  },\n  textArea: {\n    display: \"flex\",\n    flexDirection: \"column-reverse\", // to autoscroll to end\n    height: \"100%\",\n    overflowX: \"none\",\n    overflowY: \"auto\",\n    border: \"2px lightgrey solid\",\n    margin: \"16px\"\n  },\n  text: {\n    fontSize: \"13px\",\n    lineHeight: \"normal\",\n    margin: \"6px\",\n    wordBreak: \"break-all\",\n  },\n  buttonArea: {\n    marginRight: \"16px\",\n    alignSelf: \"flex-end\",\n  }\n});\n\n\nexport class UploadLogView extends Component {\n\n  handleClose = () => {\n    return this.props.clearUploadLog();\n  }\n\n  handleCancel = () => {\n    return this.props.cancelUpload();\n  }\n\n\n  render() {\n\n    const { uploadLog, classes } = this.props;\n    const logLines = uploadLog ? uploadLog.split(\"\\n\") : [];\n    let i=0;\n    const logLinesHtml = logLines.map((line) => (\n      <Typography className={ classes.text }\n          key={ i++ }>\n        { line }\n      </Typography>\n    ));\n\n    // hack because we do not have a async action with proper redux states for uploading yet\n    const uploadFinished = uploadLog && (\n      uploadLog.includes(doneMessage) || uploadLog.includes(doneWithErrorMessage)\n      || uploadLog.includes(doneWithCancelledMessage));\n\n    return (\n      <Modal open={ Boolean(uploadLog) }\n          aria-labelledby=\"simple-modal-title\"\n          aria-describedby=\"simple-modal-description\"\n          disableBackdropClick={ true }\n          onClose={ this.handleClose }>\n        <div className={ classes.paper }>\n          <div  className={ classes.headingArea }>\n          <Typography variant=\"h6\"\n              id=\"modal-title\">\n            Poi upload\n          </Typography>\n          {uploadFinished ? null :\n            <CircularProgress className={ classes.progress } />\n          }\n          </div>\n          <div className={ classes.textArea }>\n            <div variant=\"body2\"\n                id=\"simple-modal-description\">\n              { logLinesHtml }\n            </div>\n          </div>\n          <div className={ classes.buttonArea }>\n            <Button disabled={ uploadFinished }\n                onClick={ this.handleCancel }>Cancel upload</Button>\n            <Button disabled={ !uploadFinished }\n                onClick={ this.handleClose }>Close</Button>\n          </div>\n        </div>\n      </Modal>\n      );\n  }\n}\n\nUploadLogView.propTypes = {\n  classes: PropTypes.object.isRequired,\n  theme: PropTypes.object.isRequired,\n  uploadLog: PropTypes.string,\n  clearUploadLog: PropTypes.func.isRequired,\n  cancelUpload: PropTypes.func.isRequired,\n};\n\nexport default withStyles(styles, {\n  withTheme: true\n})(UploadLogView);\n"],"sourceRoot":""}